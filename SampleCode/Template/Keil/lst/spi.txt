; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xEE\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\spi.crf ..\..\..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;355      */
;;;356    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;357    {
;;;358        uint32_t u32PllFreq = 0, u32PllReg;
;;;359        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;360        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;361    
;;;362        u32PllReg = CLK->PLLCON;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;363    
;;;364        if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;365            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;366    
;;;367        if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
;;;368            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;369        else
;;;370            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;371    
;;;372        if(u32PllReg & CLK_PLLCON_BP_Msk)
;;;373            return u32FIN;      /* PLL is in bypass mode */
;;;374    
;;;375        /* PLL is output enabled in normal work mode */
;;;376        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
;;;377        u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
;;;378        u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
;;;379    
;;;380        /* u32FIN is shifted 2 bits to avoid overflow */
;;;381        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;382    
;;;383        return u32PllFreq;
;;;384    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;367
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;372
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;376
000026  0f92              LSRS     r2,r2,#30             ;376
000028  466b              MOV      r3,sp                 ;376
00002a  5c9b              LDRB     r3,[r3,r2]            ;376
00002c  05ca              LSLS     r2,r1,#23             ;377
00002e  0489              LSLS     r1,r1,#18             ;378
000030  0dd2              LSRS     r2,r2,#23             ;377
000032  0ec9              LSRS     r1,r1,#27             ;378
000034  1c89              ADDS     r1,r1,#2              ;378
000036  0880              LSRS     r0,r0,#2              ;381
000038  1c92              ADDS     r2,r2,#2              ;381
00003a  4359              MULS     r1,r3,r1              ;381
00003c  4350              MULS     r0,r2,r0              ;381
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;381
000044  bd08              POP      {r3,pc}
;;;385    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.SPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearIntFlag PROC
;;;507      */
;;;508    void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;509    {
000002  d004              BEQ      |L2.14|
;;;510        if(u32Mask & SPI_UNIT_INT_MASK)
;;;511            spi->CNTRL |= SPI_CNTRL_IF_Msk; /* Clear unit transfer interrupt flag */
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  041b              LSLS     r3,r3,#16
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L2.14|
;;;512    
;;;513        if(u32Mask & SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L2.28|
;;;514            spi->CNTRL2 |= SPI_CNTRL2_SLV_START_INTSTS_Msk; /* Clear slave 3-wire mode start interrupt flag */
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  02db              LSLS     r3,r3,#11
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L2.28|
;;;515    
;;;516        if(u32Mask & SPI_FIFO_RXOV_INT_MASK)
00001c  06ca              LSLS     r2,r1,#27
00001e  d501              BPL      |L2.36|
;;;517            spi->STATUS = SPI_STATUS_RX_OVERRUN_Msk; /* Clear RX overrun interrupt flag */
000020  2204              MOVS     r2,#4
000022  6442              STR      r2,[r0,#0x44]
                  |L2.36|
;;;518    
;;;519        if(u32Mask & SPI_FIFO_TIMEOUT_INT_MASK)
000024  0689              LSLS     r1,r1,#26
000026  d502              BPL      |L2.46|
;;;520            spi->STATUS = SPI_STATUS_TIMEOUT_Msk; /* Clear RX time-out interrupt flag */
000028  2101              MOVS     r1,#1
00002a  0509              LSLS     r1,r1,#20
00002c  6441              STR      r1,[r0,#0x44]
                  |L2.46|
;;;521    }
00002e  4770              BX       lr
;;;522    
                          ENDP


                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;178      */
;;;179    void SPI_ClearRxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;180    {
;;;181        spi->FIFO_CTL |= SPI_FIFO_CTL_RX_CLR_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;182    }
000008  4770              BX       lr
;;;183    
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;189      */
;;;190    void SPI_ClearTxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;191    {
;;;192        spi->FIFO_CTL |= SPI_FIFO_CTL_TX_CLR_Msk;
000002  2202              MOVS     r2,#2
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;193    }
000008  4770              BX       lr
;;;194    
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;156      */
;;;157    void SPI_Close(SPI_T *spi)
000000  4a07              LDR      r2,|L5.32|
;;;158    {
;;;159        if(spi == SPI0)
;;;160        {
;;;161            /* Reset SPI */
;;;162            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI0_RST_Msk;
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
000006  4290              CMP      r0,r2                 ;159
;;;163            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI0_RST_Msk;
;;;164        }
;;;165        else
;;;166        {
;;;167            /* Reset SPI */
;;;168            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI1_RST_Msk;
000008  68ca              LDR      r2,[r1,#0xc]
00000a  d101              BNE      |L5.16|
00000c  1480              ASRS     r0,r0,#18             ;162
00000e  e001              B        |L5.20|
                  |L5.16|
000010  2001              MOVS     r0,#1
000012  0340              LSLS     r0,r0,#13
                  |L5.20|
000014  4302              ORRS     r2,r2,r0              ;162
000016  60ca              STR      r2,[r1,#0xc]          ;162
000018  68ca              LDR      r2,[r1,#0xc]          ;163
00001a  4382              BICS     r2,r2,r0              ;163
00001c  60ca              STR      r2,[r1,#0xc]          ;163
;;;169            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI1_RST_Msk;
;;;170        }
;;;171    }
00001e  4770              BX       lr
;;;172    
                          ENDP

                  |L5.32|
                          DCD      0x40030000

                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;200      */
;;;201    void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;202    {
;;;203        spi->SSR &= ~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SSR_Msk);
000002  2209              MOVS     r2,#9
000004  4391              BICS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;204    }
000008  4770              BX       lr
;;;205    
                          ENDP


                          AREA ||i.SPI_DisableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_DisableFIFO PROC
;;;331      */
;;;332    void SPI_DisableFIFO(SPI_T *spi)
000000  6801              LDR      r1,[r0,#0]
;;;333    {
;;;334        spi->CNTRL &= ~SPI_CNTRL_FIFO_Msk;
000002  2201              MOVS     r2,#1
000004  0552              LSLS     r2,r2,#21
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;335    }
00000a  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;427      */
;;;428    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;429    {
000002  d004              BEQ      |L8.14|
;;;430        /* Disable unit transfer interrupt flag */
;;;431        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;432            spi->CNTRL &= ~SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L8.14|
;;;433    
;;;434        /* Disable slave 3-wire mode start interrupt flag */
;;;435        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L8.28|
;;;436            spi->CNTRL2 &= ~SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  439a              BICS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L8.28|
;;;437    
;;;438        /* Disable TX threshold interrupt flag */
;;;439        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L8.40|
;;;440            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  439a              BICS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L8.40|
;;;441    
;;;442        /* Disable RX threshold interrupt flag */
;;;443        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L8.52|
;;;444            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  439a              BICS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L8.52|
;;;445    
;;;446        /* Disable RX overrun interrupt flag */
;;;447        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L8.64|
;;;448            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  439a              BICS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L8.64|
;;;449    
;;;450        /* Disable RX time-out interrupt flag */
;;;451        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L8.78|
;;;452            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4391              BICS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L8.78|
;;;453    }
00004e  4770              BX       lr
;;;454    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;214      */
;;;215    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  b510              PUSH     {r4,lr}
;;;216    {
;;;217        spi->SSR = (spi->SSR & (~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk))) | (u32SSPinMask | u32ActiveLevel | SPI_SSR_AUTOSS_Msk);
000002  6883              LDR      r3,[r0,#8]
000004  240d              MOVS     r4,#0xd
000006  43a3              BICS     r3,r3,r4
000008  4311              ORRS     r1,r1,r2
00000a  430b              ORRS     r3,r3,r1
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6083              STR      r3,[r0,#8]
;;;218    }
000012  bd10              POP      {r4,pc}
;;;219    
                          ENDP


                          AREA ||i.SPI_EnableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_EnableFIFO PROC
;;;316      */
;;;317    void SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  0709              LSLS     r1,r1,#28
;;;318    {
;;;319        spi->FIFO_CTL = (spi->FIFO_CTL & ~(SPI_FIFO_CTL_TX_THRESHOLD_Msk | SPI_FIFO_CTL_RX_THRESHOLD_Msk)) |
000002  0612              LSLS     r2,r2,#24
000004  4311              ORRS     r1,r1,r2
000006  6c02              LDR      r2,[r0,#0x40]
000008  2377              MOVS     r3,#0x77
00000a  061b              LSLS     r3,r3,#24
00000c  439a              BICS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6401              STR      r1,[r0,#0x40]
;;;320                        ((u32TxThreshold << SPI_FIFO_CTL_TX_THRESHOLD_Pos) |
;;;321                         (u32RxThreshold << SPI_FIFO_CTL_RX_THRESHOLD_Pos));
;;;322    
;;;323        spi->CNTRL |= SPI_CNTRL_FIFO_Msk;
000012  6801              LDR      r1,[r0,#0]
000014  2201              MOVS     r2,#1
000016  0552              LSLS     r2,r2,#21
000018  4311              ORRS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;324    }
00001c  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;389      */
;;;390    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;391    {
000002  d004              BEQ      |L11.14|
;;;392        /* Enable unit transfer interrupt flag */
;;;393        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;394            spi->CNTRL |= SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L11.14|
;;;395    
;;;396        /* Enable slave 3-wire mode start interrupt flag */
;;;397        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L11.28|
;;;398            spi->CNTRL2 |= SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L11.28|
;;;399    
;;;400        /* Enable TX threshold interrupt flag */
;;;401        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L11.40|
;;;402            spi->FIFO_CTL |= SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  431a              ORRS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L11.40|
;;;403    
;;;404        /* Enable RX threshold interrupt flag */
;;;405        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L11.52|
;;;406            spi->FIFO_CTL |= SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  431a              ORRS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L11.52|
;;;407    
;;;408        /* Enable RX overrun interrupt flag */
;;;409        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L11.64|
;;;410            spi->FIFO_CTL |= SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  431a              ORRS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L11.64|
;;;411    
;;;412        /* Enable RX time-out interrupt flag */
;;;413        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L11.78|
;;;414            spi->FIFO_CTL |= SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4311              ORRS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L11.78|
;;;415    }
00004e  4770              BX       lr
;;;416    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;342      */
;;;343    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b570              PUSH     {r4-r6,lr}
;;;344    {
000002  4605              MOV      r5,r0
;;;345        uint32_t u32Div;
;;;346        uint32_t u32ClkSrc;
;;;347    
;;;348        /* Get DIVIDER setting */
;;;349        u32Div = (spi->DIVIDER & SPI_DIVIDER_DIVIDER_Msk) >> SPI_DIVIDER_DIVIDER_Pos;
000004  6840              LDR      r0,[r0,#4]
;;;350    
;;;351        /* Check clock source of SPI */
;;;352        if(spi == SPI0)
000006  490d              LDR      r1,|L12.60|
000008  b2c4              UXTB     r4,r0                 ;349
;;;353        {
;;;354            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
00000a  480d              LDR      r0,|L12.64|
00000c  428d              CMP      r5,r1                 ;352
;;;355                u32ClkSrc = CLK_GetHCLKFreq();
;;;356            else
;;;357                u32ClkSrc = CLK_GetPLLClockFreq();
;;;358        }
;;;359        else
;;;360        {
;;;361            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
00000e  6940              LDR      r0,[r0,#0x14]
000010  d101              BNE      |L12.22|
000012  06c0              LSLS     r0,r0,#27             ;354
000014  e000              B        |L12.24|
                  |L12.22|
000016  0680              LSLS     r0,r0,#26
                  |L12.24|
000018  2800              CMP      r0,#0                 ;354
00001a  da02              BGE      |L12.34|
;;;362                u32ClkSrc = CLK_GetHCLKFreq();
00001c  f7fffffe          BL       CLK_GetHCLKFreq
000020  e001              B        |L12.38|
                  |L12.34|
;;;363            else
;;;364                u32ClkSrc = CLK_GetPLLClockFreq();
000022  f7fffffe          BL       CLK_GetPLLClockFreq
                  |L12.38|
;;;365        }
;;;366    
;;;367        if(spi->CNTRL2 & SPI_CNTRL2_BCn_Msk)   /* BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
000026  6be9              LDR      r1,[r5,#0x3c]
000028  2900              CMP      r1,#0
00002a  da01              BGE      |L12.48|
;;;368        {
;;;369            /* Return SPI bus clock rate */
;;;370            return (u32ClkSrc / (u32Div + 1));
00002c  1c61              ADDS     r1,r4,#1
00002e  e001              B        |L12.52|
                  |L12.48|
;;;371        }
;;;372        else     /* BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;373        {
;;;374            /* Return SPI bus clock rate */
;;;375            return (u32ClkSrc / ((u32Div + 1) * 2));
000030  0061              LSLS     r1,r4,#1
000032  1c89              ADDS     r1,r1,#2
                  |L12.52|
000034  f7fffffe          BL       __aeabi_uidivmod
;;;376        }
;;;377    }
000038  bd70              POP      {r4-r6,pc}
;;;378    
                          ENDP

00003a  0000              DCW      0x0000
                  |L12.60|
                          DCD      0x40030000
                  |L12.64|
                          DCD      0x50000200

                          AREA ||i.SPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_GetIntFlag PROC
;;;465      */
;;;466    uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;467    {
;;;468        uint32_t u32IntFlag = 0;
000002  2000              MOVS     r0,#0
;;;469    
;;;470        /* Check unit transfer interrupt flag */
;;;471        if((u32Mask & SPI_UNIT_INT_MASK) && (spi->CNTRL & SPI_CNTRL_IF_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L13.16|
000008  6813              LDR      r3,[r2,#0]
00000a  03db              LSLS     r3,r3,#15
00000c  d500              BPL      |L13.16|
;;;472            u32IntFlag |= SPI_UNIT_INT_MASK;
00000e  2001              MOVS     r0,#1
                  |L13.16|
;;;473    
;;;474        /* Check slave 3-wire mode start interrupt flag */
;;;475        if((u32Mask & SPI_SSTA_INT_MASK) && (spi->CNTRL2 & SPI_CNTRL2_SLV_START_INTSTS_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L13.30|
000014  6bd3              LDR      r3,[r2,#0x3c]
000016  051b              LSLS     r3,r3,#20
000018  d501              BPL      |L13.30|
;;;476            u32IntFlag |= SPI_SSTA_INT_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L13.30|
;;;477    
;;;478        /* Check TX threshold interrupt flag */
;;;479        if((u32Mask & SPI_FIFO_TX_INT_MASK) && (spi->STATUS & SPI_STATUS_TX_INTSTS_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L13.44|
000022  6c53              LDR      r3,[r2,#0x44]
000024  06db              LSLS     r3,r3,#27
000026  d501              BPL      |L13.44|
;;;480            u32IntFlag |= SPI_FIFO_TX_INT_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L13.44|
;;;481    
;;;482        /* Check RX threshold interrupt flag */
;;;483        if((u32Mask & SPI_FIFO_RX_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_INTSTS_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L13.58|
000030  6c53              LDR      r3,[r2,#0x44]
000032  07db              LSLS     r3,r3,#31
000034  d001              BEQ      |L13.58|
;;;484            u32IntFlag |= SPI_FIFO_RX_INT_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L13.58|
;;;485    
;;;486        /* Check RX overrun interrupt flag */
;;;487        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_OVERRUN_Msk))
00003a  06cb              LSLS     r3,r1,#27
00003c  d504              BPL      |L13.72|
00003e  6c53              LDR      r3,[r2,#0x44]
000040  075b              LSLS     r3,r3,#29
000042  d501              BPL      |L13.72|
;;;488            u32IntFlag |= SPI_FIFO_RXOV_INT_MASK;
000044  2310              MOVS     r3,#0x10
000046  4318              ORRS     r0,r0,r3
                  |L13.72|
;;;489    
;;;490        /* Check RX time-out interrupt flag */
;;;491        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) && (spi->STATUS & SPI_STATUS_TIMEOUT_Msk))
000048  0689              LSLS     r1,r1,#26
00004a  d504              BPL      |L13.86|
00004c  6c51              LDR      r1,[r2,#0x44]
00004e  02c9              LSLS     r1,r1,#11
000050  d501              BPL      |L13.86|
;;;492            u32IntFlag |= SPI_FIFO_TIMEOUT_INT_MASK;
000052  2120              MOVS     r1,#0x20
000054  4308              ORRS     r0,r0,r1
                  |L13.86|
;;;493    
;;;494        return u32IntFlag;
;;;495    }
000056  4770              BX       lr
;;;496    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;533      */
;;;534    uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;535    {
;;;536        uint32_t u32Flag = 0;
000002  2000              MOVS     r0,#0
;;;537    
;;;538        /* Check busy status */
;;;539        if((u32Mask & SPI_BUSY_MASK) && (spi->CNTRL & SPI_CNTRL_GO_BUSY_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L14.16|
000008  6813              LDR      r3,[r2,#0]
00000a  07db              LSLS     r3,r3,#31
00000c  d000              BEQ      |L14.16|
;;;540            u32Flag |= SPI_BUSY_MASK;
00000e  2001              MOVS     r0,#1
                  |L14.16|
;;;541    
;;;542        /* Check RX empty flag */
;;;543        if((u32Mask & SPI_RX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_RX_EMPTY_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L14.30|
000014  6813              LDR      r3,[r2,#0]
000016  01db              LSLS     r3,r3,#7
000018  d501              BPL      |L14.30|
;;;544            u32Flag |= SPI_RX_EMPTY_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L14.30|
;;;545    
;;;546        /* Check RX full flag */
;;;547        if((u32Mask & SPI_RX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_RX_FULL_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L14.44|
000022  6813              LDR      r3,[r2,#0]
000024  019b              LSLS     r3,r3,#6
000026  d501              BPL      |L14.44|
;;;548            u32Flag |= SPI_RX_FULL_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L14.44|
;;;549    
;;;550        /* Check TX empty flag */
;;;551        if((u32Mask & SPI_TX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_TX_EMPTY_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L14.58|
000030  6813              LDR      r3,[r2,#0]
000032  015b              LSLS     r3,r3,#5
000034  d501              BPL      |L14.58|
;;;552            u32Flag |= SPI_TX_EMPTY_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L14.58|
;;;553    
;;;554        /* Check TX full flag */
;;;555        if((u32Mask & SPI_TX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_TX_FULL_Msk))
00003a  06c9              LSLS     r1,r1,#27
00003c  d504              BPL      |L14.72|
00003e  6811              LDR      r1,[r2,#0]
000040  0109              LSLS     r1,r1,#4
000042  d501              BPL      |L14.72|
;;;556            u32Flag |= SPI_TX_FULL_MASK;
000044  2110              MOVS     r1,#0x10
000046  4308              ORRS     r0,r0,r1
                  |L14.72|
;;;557    
;;;558        return u32Flag;
;;;559    }
000048  4770              BX       lr
;;;560    
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;39       */
;;;40     uint32_t SPI_Open(SPI_T *spi,
000000  b5f8              PUSH     {r3-r7,lr}
;;;41                       uint32_t u32MasterSlave,
;;;42                       uint32_t u32SPIMode,
;;;43                       uint32_t u32DataWidth,
;;;44                       uint32_t u32BusClock)
;;;45     {
;;;46         uint32_t u32ClkSrc = 0, u32Div, u32HCLKFreq;
;;;47     
;;;48         if(u32DataWidth == 32)
000002  9e06              LDR      r6,[sp,#0x18]
000004  460d              MOV      r5,r1                 ;45
000006  4604              MOV      r4,r0                 ;45
000008  2b20              CMP      r3,#0x20
00000a  d100              BNE      |L15.14|
;;;49             u32DataWidth = 0;
00000c  2300              MOVS     r3,#0
                  |L15.14|
;;;50     
;;;51         /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;52         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000e  00d8              LSLS     r0,r3,#3
000010  4328              ORRS     r0,r0,r5
000012  4310              ORRS     r0,r0,r2
000014  6020              STR      r0,[r4,#0]
;;;53     
;;;54         /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;55         spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000016  6be0              LDR      r0,[r4,#0x3c]
000018  2101              MOVS     r1,#1
00001a  07c9              LSLS     r1,r1,#31
00001c  4308              ORRS     r0,r0,r1
00001e  63e0              STR      r0,[r4,#0x3c]
;;;56         /* Get system clock frequency */
;;;57         u32HCLKFreq = CLK_GetHCLKFreq();
000020  f7fffffe          BL       CLK_GetHCLKFreq
000024  2200              MOVS     r2,#0
;;;58     
;;;59         if(u32MasterSlave == SPI_MASTER)
;;;60         {
;;;61             /* Default setting: slave select signal is active low; disable automatic slave select function. */
;;;62             spi->SSR = SPI_SS_ACTIVE_LOW;
;;;63     
;;;64             /* Check clock source of SPI */
;;;65             if(spi == SPI0)
000026  493d              LDR      r1,|L15.284|
000028  4607              MOV      r7,r0                 ;57
00002a  2d00              CMP      r5,#0                 ;59
00002c  d008              BEQ      |L15.64|
;;;66             {
;;;67                 if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
;;;68                     u32ClkSrc = u32HCLKFreq;
;;;69                 else
;;;70                     u32ClkSrc = CLK_GetPLLClockFreq();
;;;71             }
;;;72             else
;;;73             {
;;;74                 if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
;;;75                     u32ClkSrc = u32HCLKFreq;
;;;76                 else
;;;77                     u32ClkSrc = CLK_GetPLLClockFreq();
;;;78             }
;;;79     
;;;80             if(u32BusClock >= u32HCLKFreq)
;;;81             {
;;;82                 /* Select HCLK as the clock source of SPI */
;;;83                 if(spi == SPI0)
;;;84                     CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
;;;85                 else
;;;86                     CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI1_S_Msk)) | CLK_CLKSEL1_SPI1_S_HCLK;
;;;87     
;;;88                 /* Set DIVIDER = 0 */
;;;89                 spi->DIVIDER = 0;
;;;90                 /* Return slave peripheral clock rate */
;;;91                 return u32HCLKFreq;
;;;92             }
;;;93             else if(u32BusClock >= u32ClkSrc)
;;;94             {
;;;95                 /* Set DIVIDER = 0 */
;;;96                 spi->DIVIDER = 0;
;;;97                 /* Return master peripheral clock rate */
;;;98                 return u32ClkSrc;
;;;99             }
;;;100            else if(u32BusClock == 0)
;;;101            {
;;;102                /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;103                spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;104                /* Set DIVIDER to the maximum value 0xFF */
;;;105                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;106                /* Return master peripheral clock rate */
;;;107                return (u32ClkSrc / ((0xFF + 1) * 2));
;;;108            }
;;;109            else
;;;110            {
;;;111                u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;112                if(u32Div > 0xFF)
;;;113                {
;;;114                    /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;115                    spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;116                    u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;117                    if(u32Div > 0xFF)
;;;118                        u32Div = 0xFF;
;;;119                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;120                    /* Return master peripheral clock rate */
;;;121                    return (u32ClkSrc / ((u32Div + 1) * 2));
;;;122                }
;;;123                else
;;;124                {
;;;125                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;126                    /* Return master peripheral clock rate */
;;;127                    return (u32ClkSrc / (u32Div + 1));
;;;128                }
;;;129            }
;;;130    
;;;131        }
;;;132        else     /* For slave mode, force the SPI peripheral clock rate to system clock rate. */
;;;133        {
;;;134            /* Default setting: slave select signal is low level active. */
;;;135            spi->SSR = SPI_SSR_SS_LTRIG_Msk;
00002e  2010              MOVS     r0,#0x10
000030  60a0              STR      r0,[r4,#8]
;;;136    
;;;137            /* Select HCLK as the clock source of SPI */
;;;138            if(spi == SPI0)
000032  428c              CMP      r4,r1
000034  d16a              BNE      |L15.268|
;;;139                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
000036  493a              LDR      r1,|L15.288|
000038  694b              LDR      r3,[r1,#0x14]
00003a  4303              ORRS     r3,r3,r0
00003c  614b              STR      r3,[r1,#0x14]
00003e  e06a              B        |L15.278|
                  |L15.64|
000040  2000              MOVS     r0,#0                 ;62
000042  60a0              STR      r0,[r4,#8]            ;62
000044  4835              LDR      r0,|L15.284|
000046  4284              CMP      r4,r0                 ;65
000048  4835              LDR      r0,|L15.288|
00004a  6940              LDR      r0,[r0,#0x14]         ;74
00004c  d101              BNE      |L15.82|
00004e  06c0              LSLS     r0,r0,#27             ;67
000050  e000              B        |L15.84|
                  |L15.82|
000052  0680              LSLS     r0,r0,#26             ;74
                  |L15.84|
000054  2800              CMP      r0,#0                 ;67
000056  da01              BGE      |L15.92|
000058  463d              MOV      r5,r7                 ;75
00005a  e002              B        |L15.98|
                  |L15.92|
00005c  f7fffffe          BL       CLK_GetPLLClockFreq
000060  4605              MOV      r5,r0                 ;77
                  |L15.98|
000062  42be              CMP      r6,r7                 ;80
000064  d30f              BCC      |L15.134|
000066  482d              LDR      r0,|L15.284|
000068  4284              CMP      r4,r0                 ;83
00006a  482d              LDR      r0,|L15.288|
00006c  d104              BNE      |L15.120|
00006e  6942              LDR      r2,[r0,#0x14]         ;84
000070  2110              MOVS     r1,#0x10              ;84
000072  430a              ORRS     r2,r2,r1              ;84
000074  6142              STR      r2,[r0,#0x14]         ;84
000076  e003              B        |L15.128|
                  |L15.120|
000078  6941              LDR      r1,[r0,#0x14]         ;86
00007a  2220              MOVS     r2,#0x20              ;86
00007c  4311              ORRS     r1,r1,r2              ;86
00007e  6141              STR      r1,[r0,#0x14]         ;86
                  |L15.128|
000080  2000              MOVS     r0,#0                 ;89
000082  6060              STR      r0,[r4,#4]            ;89
000084  e048              B        |L15.280|
                  |L15.134|
000086  42ae              CMP      r6,r5                 ;93
000088  d303              BCC      |L15.146|
00008a  2000              MOVS     r0,#0                 ;96
00008c  6060              STR      r0,[r4,#4]            ;96
00008e  4628              MOV      r0,r5                 ;98
;;;140            else
;;;141                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI1_S_Msk)) | CLK_CLKSEL1_SPI1_S_HCLK;
;;;142    
;;;143            /* Set DIVIDER = 0 */
;;;144            spi->DIVIDER = 0;
;;;145            /* Return slave peripheral clock rate */
;;;146            return u32HCLKFreq;
;;;147        }
;;;148    
;;;149    }
000090  bdf8              POP      {r3-r7,pc}
                  |L15.146|
000092  2e00              CMP      r6,#0                 ;100
000094  d028              BEQ      |L15.232|
000096  200a              MOVS     r0,#0xa               ;111
000098  462f              MOV      r7,r5                 ;111
00009a  4347              MULS     r7,r0,r7              ;111
00009c  4631              MOV      r1,r6                 ;111
00009e  4638              MOV      r0,r7                 ;111
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  210a              MOVS     r1,#0xa               ;111
0000a6  1d40              ADDS     r0,r0,#5              ;111
0000a8  f7fffffe          BL       __aeabi_uidivmod
0000ac  1e40              SUBS     r0,r0,#1              ;111
0000ae  28ff              CMP      r0,#0xff              ;112
0000b0  d924              BLS      |L15.252|
0000b2  6be0              LDR      r0,[r4,#0x3c]         ;115
0000b4  0040              LSLS     r0,r0,#1              ;115
0000b6  0840              LSRS     r0,r0,#1              ;115
0000b8  63e0              STR      r0,[r4,#0x3c]         ;115
0000ba  0071              LSLS     r1,r6,#1              ;116
0000bc  4638              MOV      r0,r7                 ;116
0000be  f7fffffe          BL       __aeabi_uidivmod
0000c2  210a              MOVS     r1,#0xa               ;116
0000c4  1d40              ADDS     r0,r0,#5              ;116
0000c6  f7fffffe          BL       __aeabi_uidivmod
0000ca  1e40              SUBS     r0,r0,#1              ;116
0000cc  28ff              CMP      r0,#0xff              ;117
0000ce  d900              BLS      |L15.210|
0000d0  20ff              MOVS     r0,#0xff              ;118
                  |L15.210|
0000d2  6861              LDR      r1,[r4,#4]            ;119
0000d4  0a09              LSRS     r1,r1,#8              ;119
0000d6  0209              LSLS     r1,r1,#8              ;119
0000d8  4301              ORRS     r1,r1,r0              ;119
0000da  6061              STR      r1,[r4,#4]            ;119
0000dc  0041              LSLS     r1,r0,#1              ;121
0000de  4628              MOV      r0,r5                 ;121
0000e0  1c89              ADDS     r1,r1,#2              ;121
                  |L15.226|
0000e2  f7fffffe          BL       __aeabi_uidivmod
0000e6  bdf8              POP      {r3-r7,pc}
                  |L15.232|
0000e8  6be0              LDR      r0,[r4,#0x3c]         ;103
0000ea  0040              LSLS     r0,r0,#1              ;103
0000ec  0840              LSRS     r0,r0,#1              ;103
0000ee  63e0              STR      r0,[r4,#0x3c]         ;103
0000f0  6860              LDR      r0,[r4,#4]            ;105
0000f2  21ff              MOVS     r1,#0xff              ;105
0000f4  4308              ORRS     r0,r0,r1              ;105
0000f6  6060              STR      r0,[r4,#4]            ;105
0000f8  0a68              LSRS     r0,r5,#9              ;107
0000fa  bdf8              POP      {r3-r7,pc}
                  |L15.252|
0000fc  6861              LDR      r1,[r4,#4]            ;125
0000fe  0a09              LSRS     r1,r1,#8              ;125
000100  0209              LSLS     r1,r1,#8              ;125
000102  4301              ORRS     r1,r1,r0              ;125
000104  6061              STR      r1,[r4,#4]            ;125
000106  1c41              ADDS     r1,r0,#1              ;127
000108  4628              MOV      r0,r5                 ;127
00010a  e7ea              B        |L15.226|
                  |L15.268|
00010c  4804              LDR      r0,|L15.288|
00010e  6941              LDR      r1,[r0,#0x14]         ;141
000110  2320              MOVS     r3,#0x20              ;141
000112  4319              ORRS     r1,r1,r3              ;141
000114  6141              STR      r1,[r0,#0x14]         ;141
                  |L15.278|
000116  6062              STR      r2,[r4,#4]            ;144
                  |L15.280|
000118  4638              MOV      r0,r7                 ;146
00011a  bdf8              POP      {r3-r7,pc}
;;;150    
                          ENDP

                  |L15.284|
                          DCD      0x40030000
                  |L15.288|
                          DCD      0x50000200

                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;230      */
;;;231    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;232    {
000002  4604              MOV      r4,r0
;;;233        uint32_t u32ClkSrc, u32HCLKFreq;
;;;234        uint32_t u32Div;
;;;235    
;;;236        /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;237        spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  460e              MOV      r6,r1                 ;232
000008  2101              MOVS     r1,#1
00000a  07c9              LSLS     r1,r1,#31
00000c  4308              ORRS     r0,r0,r1
00000e  63e0              STR      r0,[r4,#0x3c]
;;;238        /* Get system clock frequency */
;;;239        u32HCLKFreq = CLK_GetHCLKFreq();
000010  f7fffffe          BL       CLK_GetHCLKFreq
000014  4607              MOV      r7,r0
;;;240    
;;;241        /* Check clock source of SPI */
;;;242        if(spi == SPI0)
000016  4830              LDR      r0,|L16.216|
000018  4284              CMP      r4,r0
;;;243        {
;;;244            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
;;;245                u32ClkSrc = u32HCLKFreq;
;;;246            else
;;;247                u32ClkSrc = CLK_GetPLLClockFreq();
;;;248        }
;;;249        else
;;;250        {
;;;251            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
00001a  4830              LDR      r0,|L16.220|
00001c  6940              LDR      r0,[r0,#0x14]
00001e  d101              BNE      |L16.36|
000020  06c0              LSLS     r0,r0,#27             ;244
000022  e000              B        |L16.38|
                  |L16.36|
000024  0680              LSLS     r0,r0,#26
                  |L16.38|
000026  2800              CMP      r0,#0                 ;244
000028  da01              BGE      |L16.46|
;;;252                u32ClkSrc = u32HCLKFreq;
00002a  463d              MOV      r5,r7
00002c  e002              B        |L16.52|
                  |L16.46|
;;;253            else
;;;254                u32ClkSrc = CLK_GetPLLClockFreq();
00002e  f7fffffe          BL       CLK_GetPLLClockFreq
000032  4605              MOV      r5,r0
                  |L16.52|
000034  2100              MOVS     r1,#0
;;;255        }
;;;256    
;;;257        if(u32BusClock >= u32HCLKFreq)
000036  42be              CMP      r6,r7
000038  d30c              BCC      |L16.84|
;;;258        {
;;;259            /* Select HCLK as the clock source of SPI */
;;;260            if(spi == SPI0)
00003a  4827              LDR      r0,|L16.216|
00003c  4284              CMP      r4,r0
;;;261                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
;;;262            else
;;;263                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI1_S_Msk)) | CLK_CLKSEL1_SPI1_S_HCLK;
00003e  4827              LDR      r0,|L16.220|
000040  6942              LDR      r2,[r0,#0x14]
000042  d101              BNE      |L16.72|
000044  2310              MOVS     r3,#0x10              ;261
000046  e000              B        |L16.74|
                  |L16.72|
000048  2320              MOVS     r3,#0x20
                  |L16.74|
00004a  431a              ORRS     r2,r2,r3
00004c  6142              STR      r2,[r0,#0x14]
;;;264    
;;;265            /* Set DIVIDER = 0 */
;;;266            spi->DIVIDER = 0;
00004e  6061              STR      r1,[r4,#4]
;;;267            /* Return slave peripheral clock rate */
;;;268            return u32HCLKFreq;
000050  4638              MOV      r0,r7
;;;269        }
;;;270        else if(u32BusClock >= u32ClkSrc)
;;;271        {
;;;272            /* Set DIVIDER = 0 */
;;;273            spi->DIVIDER = 0;
;;;274            /* Return master peripheral clock rate */
;;;275            return u32ClkSrc;
;;;276        }
;;;277        else if(u32BusClock == 0)
;;;278        {
;;;279            /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;280            spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;281            /* Set DIVIDER to the maximum value 0xFF */
;;;282            spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;283            /* Return master peripheral clock rate */
;;;284            return (u32ClkSrc / ((0xFF + 1) * 2));
;;;285        }
;;;286        else
;;;287        {
;;;288            u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;289            if(u32Div > 0xFF)
;;;290            {
;;;291                /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;292                spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;293                u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;294                if(u32Div > 0xFF)
;;;295                    u32Div = 0xFF;
;;;296                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;297                /* Return master peripheral clock rate */
;;;298                return (u32ClkSrc / ((u32Div + 1) * 2));
;;;299            }
;;;300            else
;;;301            {
;;;302                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;303                /* Return master peripheral clock rate */
;;;304                return (u32ClkSrc / (u32Div + 1));
;;;305            }
;;;306        }
;;;307    }
000052  bdf8              POP      {r3-r7,pc}
                  |L16.84|
000054  42ae              CMP      r6,r5                 ;270
000056  d302              BCC      |L16.94|
000058  6061              STR      r1,[r4,#4]            ;273
00005a  4628              MOV      r0,r5                 ;275
00005c  bdf8              POP      {r3-r7,pc}
                  |L16.94|
00005e  2e00              CMP      r6,#0                 ;277
000060  d028              BEQ      |L16.180|
000062  200a              MOVS     r0,#0xa               ;288
000064  462f              MOV      r7,r5                 ;288
000066  4347              MULS     r7,r0,r7              ;288
000068  4631              MOV      r1,r6                 ;288
00006a  4638              MOV      r0,r7                 ;288
00006c  f7fffffe          BL       __aeabi_uidivmod
000070  210a              MOVS     r1,#0xa               ;288
000072  1d40              ADDS     r0,r0,#5              ;288
000074  f7fffffe          BL       __aeabi_uidivmod
000078  1e40              SUBS     r0,r0,#1              ;288
00007a  28ff              CMP      r0,#0xff              ;289
00007c  d924              BLS      |L16.200|
00007e  6be0              LDR      r0,[r4,#0x3c]         ;292
000080  0040              LSLS     r0,r0,#1              ;292
000082  0840              LSRS     r0,r0,#1              ;292
000084  63e0              STR      r0,[r4,#0x3c]         ;292
000086  0071              LSLS     r1,r6,#1              ;293
000088  4638              MOV      r0,r7                 ;293
00008a  f7fffffe          BL       __aeabi_uidivmod
00008e  210a              MOVS     r1,#0xa               ;293
000090  1d40              ADDS     r0,r0,#5              ;293
000092  f7fffffe          BL       __aeabi_uidivmod
000096  1e40              SUBS     r0,r0,#1              ;293
000098  28ff              CMP      r0,#0xff              ;294
00009a  d900              BLS      |L16.158|
00009c  20ff              MOVS     r0,#0xff              ;295
                  |L16.158|
00009e  6861              LDR      r1,[r4,#4]            ;296
0000a0  0a09              LSRS     r1,r1,#8              ;296
0000a2  0209              LSLS     r1,r1,#8              ;296
0000a4  4301              ORRS     r1,r1,r0              ;296
0000a6  6061              STR      r1,[r4,#4]            ;296
0000a8  0041              LSLS     r1,r0,#1              ;298
0000aa  4628              MOV      r0,r5                 ;298
0000ac  1c89              ADDS     r1,r1,#2              ;298
                  |L16.174|
0000ae  f7fffffe          BL       __aeabi_uidivmod
0000b2  bdf8              POP      {r3-r7,pc}
                  |L16.180|
0000b4  6be0              LDR      r0,[r4,#0x3c]         ;280
0000b6  0040              LSLS     r0,r0,#1              ;280
0000b8  0840              LSRS     r0,r0,#1              ;280
0000ba  63e0              STR      r0,[r4,#0x3c]         ;280
0000bc  6860              LDR      r0,[r4,#4]            ;282
0000be  21ff              MOVS     r1,#0xff              ;282
0000c0  4308              ORRS     r0,r0,r1              ;282
0000c2  6060              STR      r0,[r4,#4]            ;282
0000c4  0a68              LSRS     r0,r5,#9              ;284
0000c6  bdf8              POP      {r3-r7,pc}
                  |L16.200|
0000c8  6861              LDR      r1,[r4,#4]            ;302
0000ca  0a09              LSRS     r1,r1,#8              ;302
0000cc  0209              LSLS     r1,r1,#8              ;302
0000ce  4301              ORRS     r1,r1,r0              ;302
0000d0  6061              STR      r1,[r4,#4]            ;302
0000d2  1c41              ADDS     r1,r0,#1              ;304
0000d4  4628              MOV      r0,r5                 ;304
0000d6  e7ea              B        |L16.174|
;;;308    
                          ENDP

                  |L16.216|
                          DCD      0x40030000
                  |L16.220|
                          DCD      0x50000200

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 132
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
