; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\dataflashprog.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\dataflashprog.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xEE\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\dataflashprog.crf ..\DataFlashProg.c]
                          THUMB

                          AREA ||i.DataFlashInit||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  DataFlashInit PROC
;;;25     
;;;26     void DataFlashInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;27     {
;;;28         uint32_t au32Config[2];
;;;29     	uint32_t u32Data = 0;
;;;30     
;;;31         SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;32         FMC_Open();
000006  f7fffffe          BL       FMC_Open
;;;33     
;;;34     	#if 1
;;;35         /* Check if Data Flash Size is 64K. If not, to re-define Data Flash size and to enable Data Flash function */
;;;36         if (FMC_ReadConfig(au32Config, 2) < 0)
00000a  2102              MOVS     r1,#2
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       FMC_ReadConfig
000012  2800              CMP      r0,#0
000014  da03              BGE      |L1.30|
;;;37         {
;;;38     		printf("%s : 1\r\n" , __FUNCTION__ );
000016  4927              LDR      r1,|L1.180|
000018  a027              ADR      r0,|L1.184|
00001a  f7fffffe          BL       __2printf
                  |L1.30|
;;;39         }
;;;40     
;;;41         if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != DATA_FLASH_BASE) )
00001e  9800              LDR      r0,[sp,#0]
000020  263f              MOVS     r6,#0x3f
000022  07c0              LSLS     r0,r0,#31
000024  02f6              LSLS     r6,r6,#11
000026  2400              MOVS     r4,#0
000028  4d26              LDR      r5,|L1.196|
00002a  2800              CMP      r0,#0
00002c  d102              BNE      |L1.52|
00002e  9801              LDR      r0,[sp,#4]
000030  42b0              CMP      r0,r6
000032  d034              BEQ      |L1.158|
                  |L1.52|
;;;42         {
;;;43             FMC_ENABLE_CFG_UPDATE();
000034  4824              LDR      r0,|L1.200|
000036  6801              LDR      r1,[r0,#0]
000038  2210              MOVS     r2,#0x10
00003a  4311              ORRS     r1,r1,r2
00003c  6001              STR      r1,[r0,#0]
;;;44             au32Config[0] &= ~0x1;
00003e  9800              LDR      r0,[sp,#0]
;;;45             au32Config[1] = DATA_FLASH_BASE;
;;;46             if (FMC_WriteConfig(au32Config, 2) < 0)
000040  2102              MOVS     r1,#2
000042  0840              LSRS     r0,r0,#1              ;44
000044  0040              LSLS     r0,r0,#1              ;44
000046  9000              STR      r0,[sp,#0]
000048  9601              STR      r6,[sp,#4]
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       FMC_WriteConfig
000050  2800              CMP      r0,#0
000052  da03              BGE      |L1.92|
;;;47     	    {
;;;48     			printf("%s : 2\r\n" , __FUNCTION__ );
000054  4917              LDR      r1,|L1.180|
000056  a01d              ADR      r0,|L1.204|
000058  f7fffffe          BL       __2printf
                  |L1.92|
;;;49     	    }
;;;50     
;;;51             FMC_ReadConfig(au32Config, 2);
00005c  2102              MOVS     r1,#2
00005e  4668              MOV      r0,sp
000060  f7fffffe          BL       FMC_ReadConfig
;;;52             if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != DATA_FLASH_BASE))
000064  9800              LDR      r0,[sp,#0]
000066  07c0              LSLS     r0,r0,#31
000068  d102              BNE      |L1.112|
00006a  9801              LDR      r0,[sp,#4]
00006c  42b0              CMP      r0,r6
00006e  d009              BEQ      |L1.132|
                  |L1.112|
;;;53             {
;;;54                 printf("Error: Program Config Failed!\n");
000070  a019              ADR      r0,|L1.216|
000072  f7fffffe          BL       __2printf
;;;55                 /* Disable FMC ISP function */
;;;56                 FMC_Close();
000076  f7fffffe          BL       FMC_Close
00007a  602c              STR      r4,[r5,#0]
;;;57                 SYS_LockReg();
;;;58     		    {
;;;59     				printf("%s : 3\r\n" , __FUNCTION__ );
00007c  490d              LDR      r1,|L1.180|
00007e  a01e              ADR      r0,|L1.248|
000080  f7fffffe          BL       __2printf
                  |L1.132|
;;;60     		    }
;;;61     
;;;62             }
;;;63     
;;;64             printf("chip reset\n");
000084  a01f              ADR      r0,|L1.260|
000086  f7fffffe          BL       __2printf
                  |L1.138|
;;;65     
;;;66             /* To check if all the debug messages are finished */
;;;67             while(!IsDebugFifoEmpty());
00008a  f7fffffe          BL       IsDebugFifoEmpty
00008e  2800              CMP      r0,#0
000090  d0fb              BEQ      |L1.138|
;;;68     		
;;;69             /* Reset Chip to reload new CONFIG value */
;;;70             SYS->IPRSTC1 |= SYS_IPRSTC1_CHIP_RST_Msk;
000092  2005              MOVS     r0,#5
000094  0700              LSLS     r0,r0,#28
000096  6881              LDR      r1,[r0,#8]
000098  2201              MOVS     r2,#1
00009a  4311              ORRS     r1,r1,r2
00009c  6081              STR      r1,[r0,#8]
                  |L1.158|
;;;71         }
;;;72     	#endif
;;;73     
;;;74         u32Data = FMC_ReadDataFlashBaseAddr();
00009e  f7fffffe          BL       FMC_ReadDataFlashBaseAddr
0000a2  4601              MOV      r1,r0
;;;75         printf("Data Flash Base Address [0x%08X]\r\n", u32Data);
0000a4  a01a              ADR      r0,|L1.272|
0000a6  f7fffffe          BL       __2printf
;;;76     	
;;;77         FMC_Close();
0000aa  f7fffffe          BL       FMC_Close
0000ae  602c              STR      r4,[r5,#0]
;;;78         SYS_LockReg();
;;;79     }
0000b0  bd7c              POP      {r2-r6,pc}
;;;80     
                          ENDP

0000b2  0000              DCW      0x0000
                  |L1.180|
                          DCD      ||.constdata||
                  |L1.184|
0000b8  2573203a          DCB      "%s : 1\r\n",0
0000bc  20310d0a
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L1.196|
                          DCD      0x50000100
                  |L1.200|
                          DCD      0x5000c000
                  |L1.204|
0000cc  2573203a          DCB      "%s : 2\r\n",0
0000d0  20320d0a
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L1.216|
0000d8  4572726f          DCB      "Error: Program Config Failed!\n",0
0000dc  723a2050
0000e0  726f6772
0000e4  616d2043
0000e8  6f6e6669
0000ec  67204661
0000f0  696c6564
0000f4  210a00  
0000f7  00                DCB      0
                  |L1.248|
0000f8  2573203a          DCB      "%s : 3\r\n",0
0000fc  20330d0a
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L1.260|
000104  63686970          DCB      "chip reset\n",0
000108  20726573
00010c  65740a00
                  |L1.272|
000110  44617461          DCB      "Data Flash Base Address [0x%08X]\r\n",0
000114  20466c61
000118  73682042
00011c  61736520
000120  41646472
000124  65737320
000128  5b307825
00012c  3038585d
000130  0d0a00  
000133  00                DCB      0

                          AREA ||i.DataFlashProgramPage||, CODE, READONLY, ALIGN=2

                  DataFlashProgramPage PROC
;;;135    
;;;136    uint32_t DataFlashProgramPage(uint32_t u32StartAddr, uint32_t * u32Buf)
000000  b5f0              PUSH     {r4-r7,lr}
;;;137    {
;;;138        uint32_t i;
;;;139    
;;;140        for(i = 0; i < FLASH_PAGE_SIZE / 4; i++)
000002  2200              MOVS     r2,#0
000004  2621              MOVS     r6,#0x21
000006  4b09              LDR      r3,|L2.44|
000008  2701              MOVS     r7,#1
                  |L2.10|
;;;141        {
;;;142            FMC_Write(u32StartAddr + i * 4, u32Buf[i]);
00000a  0094              LSLS     r4,r2,#2
00000c  1825              ADDS     r5,r4,r0
00000e  590c              LDR      r4,[r1,r4]
000010  60de              STR      r6,[r3,#0xc]
000012  605d              STR      r5,[r3,#4]
000014  609c              STR      r4,[r3,#8]
000016  611f              STR      r7,[r3,#0x10]
000018  f3bf8f6f          ISB      
                  |L2.28|
00001c  691c              LDR      r4,[r3,#0x10]
00001e  2c00              CMP      r4,#0
000020  d1fc              BNE      |L2.28|
000022  1c52              ADDS     r2,r2,#1
000024  2a80              CMP      r2,#0x80              ;140
000026  d3f0              BCC      |L2.10|
;;;143        }
;;;144    
;;;145        return 0;
000028  2000              MOVS     r0,#0
;;;146    }
00002a  bdf0              POP      {r4-r7,pc}
;;;147    
                          ENDP

                  |L2.44|
                          DCD      0x5000c000

                          AREA ||i.DataFlashRead||, CODE, READONLY, ALIGN=2

                  DataFlashRead PROC
;;;103    
;;;104    void DataFlashRead(uint32_t addr, uint32_t size, uint32_t buffer)
000000  b5fe              PUSH     {r1-r7,lr}
;;;105    {
000002  4617              MOV      r7,r2
;;;106        /* This is low level read function of USB Mass Storage */
;;;107        int32_t len;
;;;108        uint32_t i;
;;;109        uint32_t * pu32Buf = (uint32_t *)buffer;
;;;110    	
;;;111        /* Modify the address to DATA_FLASH_BASE */
;;;112        addr += DATA_FLASH_BASE;
000004  9201              STR      r2,[sp,#4]
000006  223f              MOVS     r2,#0x3f
000008  02d2              LSLS     r2,r2,#11
00000a  460e              MOV      r6,r1                 ;105
00000c  1885              ADDS     r5,r0,r2
;;;113    
;;;114        len = (int32_t)size;
;;;115    
;;;116        SYS_UnlockReg();
00000e  f7fffffe          BL       SYS_UnlockReg
;;;117        FMC_Open();
000012  f7fffffe          BL       FMC_Open
;;;118        FMC_ENABLE_AP_UPDATE();
000016  4911              LDR      r1,|L3.92|
000018  6808              LDR      r0,[r1,#0]
00001a  2208              MOVS     r2,#8
00001c  4310              ORRS     r0,r0,r2
00001e  6008              STR      r0,[r1,#0]
;;;119    	
;;;120        while(len >= BUFFER_PAGE_SIZE)
000020  e00e              B        |L3.64|
                  |L3.34|
;;;121        {
;;;122            for(i = 0; i < BUFFER_PAGE_SIZE / 4; i++)
000022  2400              MOVS     r4,#0
                  |L3.36|
;;;123                pu32Buf[i] = FMC_Read(addr + i * 4);
000024  00a1              LSLS     r1,r4,#2
000026  1948              ADDS     r0,r1,r5
000028  9100              STR      r1,[sp,#0]
00002a  f7fffffe          BL       FMC_Read
00002e  9a01              LDR      r2,[sp,#4]
000030  9900              LDR      r1,[sp,#0]
000032  1c64              ADDS     r4,r4,#1
000034  5050              STR      r0,[r2,r1]
000036  d0f5              BEQ      |L3.36|
000038  1d3f              ADDS     r7,r7,#4              ;122
;;;124            addr   += BUFFER_PAGE_SIZE;
;;;125            buffer += BUFFER_PAGE_SIZE;
;;;126            len  -= BUFFER_PAGE_SIZE;
;;;127            pu32Buf = (uint32_t *)buffer;
00003a  1d2d              ADDS     r5,r5,#4
00003c  1f36              SUBS     r6,r6,#4
00003e  9701              STR      r7,[sp,#4]
                  |L3.64|
000040  2e04              CMP      r6,#4                 ;120
000042  daee              BGE      |L3.34|
;;;128        }
;;;129    
;;;130    	FMC_DISABLE_AP_UPDATE();
000044  4a05              LDR      r2,|L3.92|
000046  6811              LDR      r1,[r2,#0]
000048  2008              MOVS     r0,#8
00004a  4381              BICS     r1,r1,r0
00004c  6011              STR      r1,[r2,#0]
;;;131        FMC_Close();
00004e  f7fffffe          BL       FMC_Close
000052  4903              LDR      r1,|L3.96|
000054  2000              MOVS     r0,#0
000056  6008              STR      r0,[r1,#0]
;;;132        SYS_LockReg();
;;;133    }
000058  bdfe              POP      {r1-r7,pc}
;;;134    
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      0x5000c000
                  |L3.96|
                          DCD      0x50000100

                          AREA ||i.DataFlashReadPage||, CODE, READONLY, ALIGN=1

                  DataFlashReadPage PROC
;;;91     
;;;92     void DataFlashReadPage(uint32_t addr, uint32_t buffer)
000000  b5f8              PUSH     {r3-r7,lr}
;;;93     {
000002  460e              MOV      r6,r1
;;;94         uint32_t i;
;;;95         uint32_t * pu32Buf = (uint32_t *)buffer;
;;;96     
;;;97         /* Modify the address to MASS_STORAGE_OFFSET */
;;;98         addr += DATA_FLASH_BASE;
000004  213f              MOVS     r1,#0x3f
000006  02c9              LSLS     r1,r1,#11
000008  1847              ADDS     r7,r0,r1
;;;99     
;;;100        for(i = 0; i < FLASH_PAGE_SIZE / 4; i++)
00000a  2400              MOVS     r4,#0
                  |L4.12|
;;;101            pu32Buf[i] = FMC_Read(addr + i * 4);
00000c  00a5              LSLS     r5,r4,#2
00000e  19e8              ADDS     r0,r5,r7
000010  f7fffffe          BL       FMC_Read
000014  1c64              ADDS     r4,r4,#1
000016  5170              STR      r0,[r6,r5]
000018  2c80              CMP      r4,#0x80              ;100
00001a  d3f7              BCC      |L4.12|
;;;102    }
00001c  bdf8              POP      {r3-r7,pc}
;;;103    
                          ENDP


                          AREA ||i.DataFlashWrite||, CODE, READONLY, ALIGN=2

                  DataFlashWrite PROC
;;;148    
;;;149    void DataFlashWrite(uint32_t addr, uint32_t size, uint32_t buffer)
000000  b5fe              PUSH     {r1-r7,lr}
;;;150    {
000002  460e              MOV      r6,r1
;;;151        /* This is low level write function of USB Mass Storage */
;;;152        int32_t len, i, offset;
;;;153        uint32_t *pu32;
;;;154        uint32_t alignAddr;
;;;155    
;;;156        /* Modify the address to DATA_FLASH_BASE */
;;;157        addr += DATA_FLASH_BASE;
000004  213f              MOVS     r1,#0x3f
000006  02c9              LSLS     r1,r1,#11
000008  4617              MOV      r7,r2                 ;150
00000a  1845              ADDS     r5,r0,r1
;;;158    
;;;159        len = (int32_t)size;
;;;160    
;;;161        SYS_UnlockReg();
00000c  f7fffffe          BL       SYS_UnlockReg
;;;162        FMC_Open();
000010  f7fffffe          BL       FMC_Open
;;;163        FMC_ENABLE_AP_UPDATE();
000014  4a34              LDR      r2,|L5.232|
000016  6810              LDR      r0,[r2,#0]
000018  2108              MOVS     r1,#8
00001a  4308              ORRS     r0,r0,r1
00001c  6010              STR      r0,[r2,#0]
;;;164    	
;;;165        if(len == FLASH_PAGE_SIZE && ((addr & (FLASH_PAGE_SIZE - 1)) == 0))
00001e  018c              LSLS     r4,r1,#6
000020  42a6              CMP      r6,r4
000022  d115              BNE      |L5.80|
000024  05e8              LSLS     r0,r5,#23
000026  d113              BNE      |L5.80|
;;;166        {
;;;167            FMC_Erase(addr);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       FMC_Erase
;;;168    
;;;169            while(len >= FLASH_PAGE_SIZE)
00002e  e00c              B        |L5.74|
                  |L5.48|
;;;170            {
;;;171                DataFlashProgramPage(addr, (uint32_t *) buffer);
000030  4639              MOV      r1,r7
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       DataFlashProgramPage
000038  35ff              ADDS     r5,r5,#0xff
00003a  3eff              SUBS     r6,r6,#0xff
00003c  35ff              ADDS     r5,r5,#0xff
00003e  3eff              SUBS     r6,r6,#0xff
000040  37ff              ADDS     r7,r7,#0xff
000042  3502              ADDS     r5,#2
000044  3e02              SUBS     r6,#2
000046  37ff              ADDS     r7,r7,#0xff
000048  3702              ADDS     r7,#2
                  |L5.74|
00004a  42a6              CMP      r6,r4                 ;169
00004c  daf0              BGE      |L5.48|
00004e  e03f              B        |L5.208|
                  |L5.80|
;;;172                len    -= FLASH_PAGE_SIZE;
;;;173                buffer += FLASH_PAGE_SIZE;
;;;174                addr   += FLASH_PAGE_SIZE;
;;;175            }
;;;176        }
;;;177        else
;;;178        {
;;;179            do
;;;180            {
;;;181                alignAddr = addr & 0x1FE00;
000050  21ff              MOVS     r1,#0xff
000052  4628              MOV      r0,r5
000054  0249              LSLS     r1,r1,#9
000056  4008              ANDS     r0,r0,r1
;;;182    
;;;183                /* Get the sector offset*/
;;;184                offset = (addr & (FLASH_PAGE_SIZE - 1));
000058  9001              STR      r0,[sp,#4]
00005a  05e8              LSLS     r0,r5,#23
00005c  0dc0              LSRS     r0,r0,#23
;;;185    
;;;186                if(offset || (size < FLASH_PAGE_SIZE))
00005e  9000              STR      r0,[sp,#0]
000060  d103              BNE      |L5.106|
000062  2001              MOVS     r0,#1
000064  0240              LSLS     r0,r0,#9
000066  4286              CMP      r6,r0
000068  d206              BCS      |L5.120|
                  |L5.106|
;;;187                {
;;;188                    /* Non 4k alignment. Note: It needs to avoid add DATA_FLASH_BASE twice. */
;;;189    //                DataFlashRead(alignAddr - DATA_FLASH_BASE, FLASH_PAGE_SIZE, (uint32_t)&g_sectorBuf[0]);
;;;190    				DataFlashReadPage(alignAddr - DATA_FLASH_BASE, /*FLASH_PAGE_SIZE,*/ (uint32_t)&g_sectorBuf[0]);
00006a  223f              MOVS     r2,#0x3f
00006c  9801              LDR      r0,[sp,#4]
00006e  02d2              LSLS     r2,r2,#11
000070  491e              LDR      r1,|L5.236|
000072  1a80              SUBS     r0,r0,r2
000074  f7fffffe          BL       DataFlashReadPage
                  |L5.120|
;;;191                }
;;;192    
;;;193                /* Update the data */
;;;194                pu32 = (uint32_t *)buffer;
;;;195    //			printf("pu32 : 0x%4X , 0x%4X , 0x%4X\r\n" , pu32[0] , buffer , &buffer);
;;;196    			
;;;197                len = FLASH_PAGE_SIZE - offset;
000078  2101              MOVS     r1,#1
00007a  9800              LDR      r0,[sp,#0]
00007c  0249              LSLS     r1,r1,#9
00007e  1a0c              SUBS     r4,r1,r0
;;;198                if(size < len)
000080  42a6              CMP      r6,r4
000082  d200              BCS      |L5.134|
;;;199                    len = size;
000084  4634              MOV      r4,r6
                  |L5.134|
;;;200    
;;;201                for(i = 0; i < len / 4; i++)
;;;202                {
;;;203                    g_sectorBuf[offset / 4 + i] = pu32[i];
000086  9900              LDR      r1,[sp,#0]
000088  9a00              LDR      r2,[sp,#0]
00008a  17c9              ASRS     r1,r1,#31
00008c  0f89              LSRS     r1,r1,#30
00008e  1889              ADDS     r1,r1,r2
000090  1089              ASRS     r1,r1,#2
000092  468e              MOV      lr,r1
000094  17e1              ASRS     r1,r4,#31             ;201
000096  0f89              LSRS     r1,r1,#30             ;201
000098  2000              MOVS     r0,#0                 ;201
00009a  1909              ADDS     r1,r1,r4              ;201
00009c  1089              ASRS     r1,r1,#2              ;201
00009e  468c              MOV      r12,r1                ;201
0000a0  e008              B        |L5.180|
                  |L5.162|
0000a2  4671              MOV      r1,lr
0000a4  180b              ADDS     r3,r1,r0
0000a6  4911              LDR      r1,|L5.236|
0000a8  0082              LSLS     r2,r0,#2
0000aa  009b              LSLS     r3,r3,#2
0000ac  185b              ADDS     r3,r3,r1
0000ae  58ba              LDR      r2,[r7,r2]
0000b0  1c40              ADDS     r0,r0,#1
0000b2  601a              STR      r2,[r3,#0]
                  |L5.180|
0000b4  4584              CMP      r12,r0                ;201
0000b6  dcf4              BGT      |L5.162|
;;;204                }
;;;205    //			printf("g_sectorBuf : 0x%4X\r\n" , g_sectorBuf[0]);
;;;206    
;;;207                FMC_Erase(alignAddr);
0000b8  9801              LDR      r0,[sp,#4]
0000ba  f7fffffe          BL       FMC_Erase
;;;208    
;;;209    			#if 1
;;;210                DataFlashProgramPage(alignAddr, (uint32_t *) g_sectorBuf);
0000be  490b              LDR      r1,|L5.236|
0000c0  9801              LDR      r0,[sp,#4]
0000c2  f7fffffe          BL       DataFlashProgramPage
;;;211    			#else
;;;212                for(i = 0; i < 16; i++)
;;;213                {
;;;214                    FMC_ProgramPage(alignAddr + (i << 8), (uint32_t *) g_sectorBuf + (i << 8));
;;;215                }
;;;216    			#endif
;;;217    
;;;218                size -= len;
0000c6  1b36              SUBS     r6,r6,r4
;;;219                addr += len;
0000c8  192d              ADDS     r5,r5,r4
;;;220                buffer += len;
0000ca  193f              ADDS     r7,r7,r4
;;;221    
;;;222            }
;;;223            while(size > 0);
0000cc  2e00              CMP      r6,#0
0000ce  d1bf              BNE      |L5.80|
                  |L5.208|
;;;224        }
;;;225    
;;;226        FMC_DISABLE_AP_UPDATE(); 	
0000d0  4805              LDR      r0,|L5.232|
0000d2  6801              LDR      r1,[r0,#0]
0000d4  2208              MOVS     r2,#8
0000d6  4391              BICS     r1,r1,r2
0000d8  6001              STR      r1,[r0,#0]
;;;227        FMC_Close();
0000da  f7fffffe          BL       FMC_Close
0000de  4904              LDR      r1,|L5.240|
0000e0  2000              MOVS     r0,#0
0000e2  6008              STR      r0,[r1,#0]
;;;228        SYS_LockReg();
;;;229    }
0000e4  bdfe              POP      {r1-r7,pc}
;;;230    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L5.232|
                          DCD      0x5000c000
                  |L5.236|
                          DCD      ||.bss||
                  |L5.240|
                          DCD      0x50000100

                          AREA ||i.FMC_Erase||, CODE, READONLY, ALIGN=2

                  FMC_Erase PROC
;;;282     */
;;;283    static __INLINE int32_t FMC_Erase(uint32_t u32addr)
000000  490b              LDR      r1,|L6.48|
;;;284    {
;;;285        FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE; /* Set ISP Command Code */
000002  2222              MOVS     r2,#0x22
000004  60ca              STR      r2,[r1,#0xc]
;;;286        FMC->ISPADR = u32addr;               /* Set Target ROM Address. The address must be page alignment. */
000006  6048              STR      r0,[r1,#4]
;;;287        FMC->ISPTRG = 0x1;                   /* Trigger to start ISP procedure */
000008  2001              MOVS     r0,#1
00000a  6108              STR      r0,[r1,#0x10]
;;;288        __ISB();                             /* To make sure ISP/CPU be Synchronized */
00000c  f3bf8f6f          ISB      
                  |L6.16|
;;;289        while(FMC->ISPTRG);                  /* Waiting for ISP Done */
000010  6908              LDR      r0,[r1,#0x10]
000012  2800              CMP      r0,#0
000014  d1fc              BNE      |L6.16|
;;;290    
;;;291        /* Check ISPFF flag to know whether erase OK or fail. */
;;;292        if(FMC->ISPCON & FMC_ISPCON_ISPFF_Msk)
000016  6808              LDR      r0,[r1,#0]
000018  0640              LSLS     r0,r0,#25
00001a  d506              BPL      |L6.42|
;;;293        {
;;;294            FMC->ISPCON |= FMC_ISPCON_ISPFF_Msk;
00001c  6808              LDR      r0,[r1,#0]
00001e  2240              MOVS     r2,#0x40
000020  4310              ORRS     r0,r0,r2
000022  6008              STR      r0,[r1,#0]
;;;295            return -1;
000024  2000              MOVS     r0,#0
000026  43c0              MVNS     r0,r0
;;;296        }
;;;297        return 0;
;;;298    }
000028  4770              BX       lr
                  |L6.42|
00002a  2000              MOVS     r0,#0                 ;297
00002c  4770              BX       lr
;;;299    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x5000c000

                          AREA ||i.FMC_Read||, CODE, READONLY, ALIGN=2

                  FMC_Read PROC
;;;258     */
;;;259    static __INLINE uint32_t FMC_Read(uint32_t u32addr)
000000  4906              LDR      r1,|L7.28|
;;;260    {
;;;261        FMC->ISPCMD = FMC_ISPCMD_READ; /* Set ISP Command Code */
000002  2200              MOVS     r2,#0
000004  60ca              STR      r2,[r1,#0xc]
;;;262        FMC->ISPADR = u32addr;         /* Set Target ROM Address. The address must be word alignment. */
000006  6048              STR      r0,[r1,#4]
;;;263        FMC->ISPTRG = 0x1;             /* Trigger to start ISP procedure */
000008  2001              MOVS     r0,#1
00000a  6108              STR      r0,[r1,#0x10]
;;;264        __ISB();                       /* To make sure ISP/CPU be Synchronized */
00000c  f3bf8f6f          ISB      
                  |L7.16|
;;;265        while(FMC->ISPTRG);            /* Waiting for ISP Done */
000010  6908              LDR      r0,[r1,#0x10]
000012  2800              CMP      r0,#0
000014  d1fc              BNE      |L7.16|
;;;266    
;;;267        return FMC->ISPDAT;
000016  6888              LDR      r0,[r1,#8]
;;;268    }
000018  4770              BX       lr
;;;269    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x5000c000

                          AREA ||i.FMC_ReadPage||, CODE, READONLY, ALIGN=1

                  FMC_ReadPage PROC
;;;81     
;;;82     uint32_t FMC_ReadPage(uint32_t u32StartAddr, uint32_t * u32Buf)
000000  b5f8              PUSH     {r3-r7,lr}
;;;83     {
000002  460e              MOV      r6,r1
000004  4607              MOV      r7,r0
;;;84         uint32_t i;
;;;85     
;;;86         for(i = 0; i < FLASH_PAGE_SIZE / 4; i++)
000006  2400              MOVS     r4,#0
                  |L8.8|
;;;87             u32Buf[i] = FMC_Read(u32StartAddr + i * 4);
000008  00a5              LSLS     r5,r4,#2
00000a  19e8              ADDS     r0,r5,r7
00000c  f7fffffe          BL       FMC_Read
000010  1c64              ADDS     r4,r4,#1
000012  5170              STR      r0,[r6,r5]
000014  2c80              CMP      r4,#0x80              ;86
000016  d3f7              BCC      |L8.8|
;;;88     
;;;89         return 0;
000018  2000              MOVS     r0,#0
;;;90     }
00001a  bdf8              POP      {r3-r7,pc}
;;;91     
                          ENDP


                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1032     */
;;;1033   static __INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1034   {
;;;1035       while(SYS->REGWRPROT != SYS_REGWRPROT_REGPROTDIS_Msk)
;;;1036       {
;;;1037           SYS->REGWRPROT = 0x59;
000002  2159              MOVS     r1,#0x59
;;;1038           SYS->REGWRPROT = 0x16;
000004  2316              MOVS     r3,#0x16
000006  4805              LDR      r0,|L9.28|
;;;1039           SYS->REGWRPROT = 0x88;
000008  2288              MOVS     r2,#0x88
00000a  e002              B        |L9.18|
                  |L9.12|
00000c  6001              STR      r1,[r0,#0]            ;1037
00000e  6003              STR      r3,[r0,#0]            ;1038
000010  6002              STR      r2,[r0,#0]
                  |L9.18|
000012  6804              LDR      r4,[r0,#0]            ;1035
000014  2c01              CMP      r4,#1                 ;1035
000016  d1f9              BNE      |L9.12|
;;;1040       }
;;;1041   }
000018  bd10              POP      {r4,pc}
;;;1042   
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x50000100

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_sectorBuf
                          %        512

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  44617461          DCB      0x44,0x61,0x74,0x61
000004  466c6173          DCB      0x46,0x6c,0x61,0x73
000008  68496e69          DCB      0x68,0x49,0x6e,0x69
00000c  7400              DCB      0x74,0x00

;*** Start embedded assembler ***

#line 1 "..\\DataFlashProg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_DataFlashProg_c_d5928c7a____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_DataFlashProg_c_d5928c7a____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_DataFlashProg_c_d5928c7a____REVSH|
#line 132
|__asm___15_DataFlashProg_c_d5928c7a____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
