; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xEE\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Check_SPI_Mode_Record||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  Check_SPI_Mode_Record PROC
;;;188    */
;;;189    void Check_SPI_Mode_Record(void)
000000  b570              PUSH     {r4-r6,lr}
;;;190    {
;;;191        record_idx = 0x00;
000002  4c20              LDR      r4,|L1.132|
000004  2000              MOVS     r0,#0
;;;192    	DataFlashRead(record_idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
000006  4622              MOV      r2,r4
000008  320c              ADDS     r2,r2,#0xc
00000a  2104              MOVS     r1,#4
00000c  6160              STR      r0,[r4,#0x14]  ; record_idx
00000e  f7fffffe          BL       DataFlashRead
;;;193    
;;;194        printf("%s:[0]:0x%04X\r\n",__FUNCTION__ ,Storage_Block[0]);
000012  4625              MOV      r5,r4
000014  350c              ADDS     r5,r5,#0xc
000016  491c              LDR      r1,|L1.136|
000018  a01c              ADR      r0,|L1.140|
00001a  682a              LDR      r2,[r5,#0]  ; Storage_Block
00001c  f7fffffe          BL       __2printf
;;;195    
;;;196        if ((Storage_Block[0] == SPI_MODE_0) || 
000020  682a              LDR      r2,[r5,#0]  ; Storage_Block
000022  2a04              CMP      r2,#4
000024  d007              BEQ      |L1.54|
;;;197            (Storage_Block[0] == SPI_MODE_1) ||
000026  2a02              CMP      r2,#2
000028  d005              BEQ      |L1.54|
;;;198            (Storage_Block[0] == SPI_MODE_2) ||
00002a  481c              LDR      r0,|L1.156|
00002c  4282              CMP      r2,r0
00002e  d002              BEQ      |L1.54|
;;;199            (Storage_Block[0] == SPI_MODE_3)
000030  1c80              ADDS     r0,r0,#2
000032  4282              CMP      r2,r0
000034  d106              BNE      |L1.68|
                  |L1.54|
;;;200            )
;;;201        {
;;;202            u32SPIMode = Storage_Block[0];
000036  4613              MOV      r3,r2
;;;203            printf("%s:Read SPI mode ready:0x%04X, u32SPIMode:0x%04X\r\n" ,__FUNCTION__ , Storage_Block[0],u32SPIMode);
000038  4913              LDR      r1,|L1.136|
00003a  a019              ADR      r0,|L1.160|
00003c  6122              STR      r2,[r4,#0x10]  ; u32SPIMode
00003e  f7fffffe          BL       __2printf
;;;204            return;
;;;205        }
;;;206        else
;;;207        {
;;;208            Storage_Block[0] = SPI_MODE_0;
;;;209            u32SPIMode = SPI_MODE_0;
;;;210    
;;;211    		DataFlashWrite(record_idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
;;;212            printf("%s:NOT correct SPI mode,set to default:0x%04X\r\n" ,__FUNCTION__ , Storage_Block[0]);
;;;213            
;;;214    	    DataFlashRead(record_idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
;;;215            printf("%s:0x%04X\r\n" ,__FUNCTION__ , u32SPIMode);
;;;216            printf("%s:Read mode[0]:0x%04X\r\n",__FUNCTION__ ,Storage_Block[0]);
;;;217        }
;;;218    }
000042  bd70              POP      {r4-r6,pc}
                  |L1.68|
000044  2004              MOVS     r0,#4                 ;208
000046  6028              STR      r0,[r5,#0]            ;209  ; Storage_Block
000048  4a0e              LDR      r2,|L1.132|
00004a  4601              MOV      r1,r0                 ;211
00004c  6120              STR      r0,[r4,#0x10]         ;211  ; u32SPIMode
00004e  320c              ADDS     r2,r2,#0xc            ;211
000050  6960              LDR      r0,[r4,#0x14]         ;211  ; record_idx
000052  f7fffffe          BL       DataFlashWrite
000056  490c              LDR      r1,|L1.136|
000058  a01e              ADR      r0,|L1.212|
00005a  682a              LDR      r2,[r5,#0]            ;212  ; Storage_Block
00005c  f7fffffe          BL       __2printf
000060  4a08              LDR      r2,|L1.132|
000062  2104              MOVS     r1,#4                 ;214
000064  320c              ADDS     r2,r2,#0xc            ;214
000066  6960              LDR      r0,[r4,#0x14]         ;214  ; record_idx
000068  f7fffffe          BL       DataFlashRead
00006c  4906              LDR      r1,|L1.136|
00006e  a025              ADR      r0,|L1.260|
000070  6922              LDR      r2,[r4,#0x10]         ;215  ; u32SPIMode
000072  f7fffffe          BL       __2printf
000076  4904              LDR      r1,|L1.136|
000078  a025              ADR      r0,|L1.272|
00007a  682a              LDR      r2,[r5,#0]            ;216  ; Storage_Block
00007c  f7fffffe          BL       __2printf
000080  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP

000082  0000              DCW      0x0000
                  |L1.132|
                          DCD      ||.data||
                  |L1.136|
                          DCD      ||.constdata||+0x16
                  |L1.140|
00008c  25733a5b          DCB      "%s:[0]:0x%04X\r\n",0
000090  305d3a30
000094  78253034
000098  580d0a00
                  |L1.156|
                          DCD      0x00000802
                  |L1.160|
0000a0  25733a52          DCB      "%s:Read SPI mode ready:0x%04X, u32SPIMode:0x%04X\r\n",0
0000a4  65616420
0000a8  53504920
0000ac  6d6f6465
0000b0  20726561
0000b4  64793a30
0000b8  78253034
0000bc  582c2075
0000c0  33325350
0000c4  494d6f64
0000c8  653a3078
0000cc  25303458
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L1.212|
0000d4  25733a4e          DCB      "%s:NOT correct SPI mode,set to default:0x%04X\r\n",0
0000d8  4f542063
0000dc  6f727265
0000e0  63742053
0000e4  5049206d
0000e8  6f64652c
0000ec  73657420
0000f0  746f2064
0000f4  65666175
0000f8  6c743a30
0000fc  78253034
000100  580d0a00
                  |L1.260|
000104  25733a30          DCB      "%s:0x%04X\r\n",0
000108  78253034
00010c  580d0a00
                  |L1.272|
000110  25733a52          DCB      "%s:Read mode[0]:0x%04X\r\n",0
000114  65616420
000118  6d6f6465
00011c  5b305d3a
000120  30782530
000124  34580d0a
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;565    
;;;566    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;567    {
;;;568        SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB4_Msk);
000002  2005              MOVS     r0,#5
000004  0700              LSLS     r0,r0,#28
000006  6b41              LDR      r1,[r0,#0x34]
000008  2210              MOVS     r2,#0x10
00000a  4391              BICS     r1,r1,r2
00000c  6341              STR      r1,[r0,#0x34]
;;;569        SYS->GPB_MFP |= (SYS_GPB_MFP_PB4_GPIO);
00000e  6b41              LDR      r1,[r0,#0x34]
000010  6341              STR      r1,[r0,#0x34]
;;;570    	
;;;571        GPIO_SetMode(PB, BIT4, GPIO_PMD_OUTPUT);
000012  2201              MOVS     r2,#1
000014  2110              MOVS     r1,#0x10
000016  4802              LDR      r0,|L2.32|
000018  f7fffffe          BL       GPIO_SetMode
;;;572    
;;;573    }
00001c  bd10              POP      {r4,pc}
;;;574    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x50004040

                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  SPI_Init PROC
;;;281    
;;;282    void SPI_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;283    {
;;;284        switch(u32SPIMode)
000002  4c13              LDR      r4,|L3.80|
000004  6922              LDR      r2,[r4,#0x10]  ; u32SPIMode
000006  2a02              CMP      r2,#2
000008  d00a              BEQ      |L3.32|
00000a  2a04              CMP      r2,#4
00000c  d005              BEQ      |L3.26|
00000e  4811              LDR      r0,|L3.84|
000010  1810              ADDS     r0,r2,r0
000012  d016              BEQ      |L3.66|
000014  2802              CMP      r0,#2
000016  d107              BNE      |L3.40|
000018  e016              B        |L3.72|
                  |L3.26|
;;;285        {
;;;286            case SPI_MODE_0:
;;;287                printf("%s:SET SPI mode 0:0x%04X\r\n" , __FUNCTION__, u32SPIMode);
00001a  490f              LDR      r1,|L3.88|
00001c  a00f              ADR      r0,|L3.92|
;;;288                break;
00001e  e001              B        |L3.36|
                  |L3.32|
;;;289            case SPI_MODE_1:
;;;290                printf("%s:SET SPI mode 1:0x%04X\r\n" , __FUNCTION__, u32SPIMode);
000020  490d              LDR      r1,|L3.88|
000022  a015              ADR      r0,|L3.120|
                  |L3.36|
000024  f7fffffe          BL       __2printf
                  |L3.40|
;;;291                break;
;;;292            case SPI_MODE_2:
;;;293                printf("%s:SET SPI mode 2:0x%04X\r\n" , __FUNCTION__, u32SPIMode);
;;;294                break;
;;;295            case SPI_MODE_3:
;;;296                printf("%s:SET SPI mode 3:0x%04X\r\n" , __FUNCTION__, u32SPIMode);
;;;297                break;
;;;298        }
;;;299    
;;;300    	SPI_Open(SPI0, SPI_MASTER, u32SPIMode, 8, SPI_FREQ);
000028  481a              LDR      r0,|L3.148|
00002a  9000              STR      r0,[sp,#0]
00002c  6922              LDR      r2,[r4,#0x10]  ; u32SPIMode
00002e  4c1a              LDR      r4,|L3.152|
000030  2308              MOVS     r3,#8
000032  2100              MOVS     r1,#0
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       SPI_Open
;;;301    	// SPI_EnableAutoSS(SPI0, SPI_SS, SPI_SS_ACTIVE_LOW);  
;;;302        SPI_DisableAutoSS(SPI0);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       SPI_DisableAutoSS
;;;303    }
000040  bd38              POP      {r3-r5,pc}
                  |L3.66|
000042  4905              LDR      r1,|L3.88|
000044  a015              ADR      r0,|L3.156|
000046  e7ed              B        |L3.36|
                  |L3.72|
000048  4903              LDR      r1,|L3.88|
00004a  a01b              ADR      r0,|L3.184|
00004c  e7ea              B        |L3.36|
;;;304    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      ||.data||
                  |L3.84|
                          DCD      0xfffff7fe
                  |L3.88|
                          DCD      ||.constdata||+0x2c
                  |L3.92|
00005c  25733a53          DCB      "%s:SET SPI mode 0:0x%04X\r\n",0
000060  45542053
000064  5049206d
000068  6f646520
00006c  303a3078
000070  25303458
000074  0d0a00  
000077  00                DCB      0
                  |L3.120|
000078  25733a53          DCB      "%s:SET SPI mode 1:0x%04X\r\n",0
00007c  45542053
000080  5049206d
000084  6f646520
000088  313a3078
00008c  25303458
000090  0d0a00  
000093  00                DCB      0
                  |L3.148|
                          DCD      0x000186a0
                  |L3.152|
                          DCD      0x40030000
                  |L3.156|
00009c  25733a53          DCB      "%s:SET SPI mode 2:0x%04X\r\n",0
0000a0  45542053
0000a4  5049206d
0000a8  6f646520
0000ac  323a3078
0000b0  25303458
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L3.184|
0000b8  25733a53          DCB      "%s:SET SPI mode 3:0x%04X\r\n",0
0000bc  45542053
0000c0  5049206d
0000c4  6f646520
0000c8  333a3078
0000cc  25303458
0000d0  0d0a00  
0000d3  00                DCB      0

                          AREA ||i.SPI_Write_Packet||, CODE, READONLY, ALIGN=2

                  SPI_Write_Packet PROC
;;;244    
;;;245    void SPI_Write_Packet(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;246    {
;;;247        static uint8_t cnt = 0;
;;;248        uint8_t packet[8] = {0};
000002  2600              MOVS     r6,#0
000004  9600              STR      r6,[sp,#0]
;;;249        uint8_t i = 0;
;;;250    
;;;251        packet[0] = 0x5A;
000006  215a              MOVS     r1,#0x5a
000008  466a              MOV      r2,sp
00000a  9601              STR      r6,[sp,#4]
00000c  7011              STRB     r1,[r2,#0]
;;;252        packet[1] = 0x5A;
;;;253        packet[2] = cnt;
00000e  4d13              LDR      r5,|L4.92|
000010  7051              STRB     r1,[r2,#1]            ;252
000012  7828              LDRB     r0,[r5,#0]  ; cnt
000014  7090              STRB     r0,[r2,#2]
;;;254        packet[3] = 0;
000016  70d6              STRB     r6,[r2,#3]
;;;255        packet[4] = 0;
000018  7116              STRB     r6,[r2,#4]
00001a  1c40              ADDS     r0,r0,#1
;;;256        packet[5] = cnt+1;
00001c  7150              STRB     r0,[r2,#5]
;;;257        packet[6] = 0x5A;
00001e  7191              STRB     r1,[r2,#6]
000020  4634              MOV      r4,r6                 ;249
;;;258        packet[7] = 0x5A;
000022  71d1              STRB     r1,[r2,#7]
;;;259    
;;;260        #if defined (MANUAL_SWITCH_MOSI_TO_GPIO)
;;;261        SwitchToFunctionPin(1);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       SwitchToFunctionPin
;;;262        #endif
;;;263    
;;;264        PC0 = 0; //SPI_SET_SS_LOW(SPI0);
00002a  4b0d              LDR      r3,|L4.96|
00002c  601e              STR      r6,[r3,#0]
;;;265    
;;;266        for (i = 0; i < 8 ;i++)
;;;267        {
;;;268            SPI_WRITE_TX(SPI0, packet[i]);
00002e  480d              LDR      r0,|L4.100|
000030  466e              MOV      r6,sp                 ;248
000032  2101              MOVS     r1,#1                 ;261
                  |L4.52|
000034  5d32              LDRB     r2,[r6,r4]
000036  6202              STR      r2,[r0,#0x20]
;;;269            SPI_TRIGGER(SPI0);
000038  6802              LDR      r2,[r0,#0]
00003a  430a              ORRS     r2,r2,r1
00003c  6002              STR      r2,[r0,#0]
                  |L4.62|
;;;270            while(SPI_IS_BUSY(SPI0)); 
00003e  6802              LDR      r2,[r0,#0]
000040  07d2              LSLS     r2,r2,#31
000042  d1fc              BNE      |L4.62|
000044  1c64              ADDS     r4,r4,#1
000046  b2e4              UXTB     r4,r4                 ;266
000048  2c08              CMP      r4,#8                 ;266
00004a  d3f3              BCC      |L4.52|
;;;271        }
;;;272    
;;;273        PC0 = 1; //SPI_SET_SS_HIGH(SPI0);
00004c  6019              STR      r1,[r3,#0]
;;;274        
;;;275        #if defined (MANUAL_SWITCH_MOSI_TO_GPIO)
;;;276        SwitchToFunctionPin(0);
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       SwitchToFunctionPin
;;;277        #endif
;;;278    
;;;279        cnt++;
000054  7828              LDRB     r0,[r5,#0]  ; cnt
000056  1c40              ADDS     r0,r0,#1
000058  7028              STRB     r0,[r5,#0]
;;;280    }
00005a  bd7c              POP      {r2-r6,pc}
;;;281    
                          ENDP

                  |L4.92|
                          DCD      ||.data||
                  |L4.96|
                          DCD      0x50004280
                  |L4.100|
                          DCD      0x40030000

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;575    
;;;576    void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;577    {
;;;578        /* Unlock protected registers */
;;;579        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;580    
;;;581        CLK_EnableXtalRC(CLK_PWRCON_OSC22M_EN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;582        CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;583    
;;;584        /* Switch HCLK clock source to Internal RC and HCLK source divide 1 */
;;;585        CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_HIRC, CLK_CLKDIV_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;586    
;;;587        /* Enable external XTAL 12MHz clock */
;;;588    //    CLK_EnableXtalRC(CLK_PWRCON_XTL12M_EN_Msk);
;;;589    
;;;590        /* Waiting for external XTAL clock ready */
;;;591    //    CLK_WaitClockReady(CLK_CLKSTATUS_XTL12M_STB_Msk);
;;;592    
;;;593        /* Set core clock as PLL_CLOCK from PLL */
;;;594        CLK_SetCoreClock(PLL_CLOCK);
00001a  481e              LDR      r0,|L5.148|
00001c  f7fffffe          BL       CLK_SetCoreClock
;;;595    
;;;596        CLK_EnableModuleClock(UART0_MODULE);
000020  4c1d              LDR      r4,|L5.152|
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       CLK_EnableModuleClock
;;;597        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART_S_HIRC, CLK_CLKDIV_UART(1));
000028  2103              MOVS     r1,#3
00002a  2200              MOVS     r2,#0
00002c  0609              LSLS     r1,r1,#24
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       CLK_SetModuleClock
;;;598    	
;;;599        CLK_EnableModuleClock(TMR1_MODULE);
000034  4c19              LDR      r4,|L5.156|
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       CLK_EnableModuleClock
;;;600      	CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1_S_HIRC, 0);
00003c  2107              MOVS     r1,#7
00003e  2200              MOVS     r2,#0
000040  0309              LSLS     r1,r1,#12
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       CLK_SetModuleClock
;;;601    
;;;602        CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL1_SPI0_S_HCLK, MODULE_NoMsk);
000048  4c15              LDR      r4,|L5.160|
00004a  2200              MOVS     r2,#0
00004c  2110              MOVS     r1,#0x10
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       CLK_SetModuleClock
;;;603        CLK_EnableModuleClock(SPI0_MODULE);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       CLK_EnableModuleClock
;;;604    
;;;605        /* Setup SPI0 multi-function pins */
;;;606        SYS->GPC_MFP &= ~(/*SYS_GPC_MFP_PC0_Msk |*/ SYS_GPC_MFP_PC1_Msk | SYS_GPC_MFP_PC2_Msk | SYS_GPC_MFP_PC3_Msk);
00005a  2005              MOVS     r0,#5
00005c  0700              LSLS     r0,r0,#28
00005e  6b82              LDR      r2,[r0,#0x38]
000060  210e              MOVS     r1,#0xe
000062  438a              BICS     r2,r2,r1
000064  6382              STR      r2,[r0,#0x38]
;;;607        SYS->GPC_MFP |= /*SYS_GPC_MFP_PC0_SPI0_SS0 |*/ SYS_GPC_MFP_PC1_SPI0_CLK | SYS_GPC_MFP_PC2_SPI0_MISO0 | SYS_GPC_MFP_PC3_SPI0_MOSI0;
000066  6b82              LDR      r2,[r0,#0x38]
000068  430a              ORRS     r2,r2,r1
00006a  6382              STR      r2,[r0,#0x38]
;;;608        SYS->ALT_MFP &= ~(/*SYS_ALT_MFP_PC0_Msk |*/ SYS_ALT_MFP_PC1_Msk | SYS_ALT_MFP_PC2_Msk | SYS_ALT_MFP_PC3_Msk);
00006c  490d              LDR      r1,|L5.164|
00006e  690a              LDR      r2,[r1,#0x10]
000070  610a              STR      r2,[r1,#0x10]
;;;609        SYS->ALT_MFP |= /*SYS_ALT_MFP_PC0_SPI0_SS0 |*/ SYS_ALT_MFP_PC1_SPI0_CLK | SYS_ALT_MFP_PC2_SPI0_MISO0 | SYS_ALT_MFP_PC3_SPI0_MOSI0;
000072  690a              LDR      r2,[r1,#0x10]
000074  610a              STR      r2,[r1,#0x10]
;;;610    
;;;611    
;;;612        SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB0_Msk | SYS_GPB_MFP_PB1_Msk);
000076  6b41              LDR      r1,[r0,#0x34]
000078  0889              LSRS     r1,r1,#2
00007a  0089              LSLS     r1,r1,#2
00007c  6341              STR      r1,[r0,#0x34]
;;;613        SYS->GPB_MFP |= (SYS_GPB_MFP_PB0_UART0_RXD | SYS_GPB_MFP_PB1_UART0_TXD);
00007e  6b41              LDR      r1,[r0,#0x34]
000080  2203              MOVS     r2,#3
000082  4311              ORRS     r1,r1,r2
000084  6341              STR      r1,[r0,#0x34]
;;;614    
;;;615       /* Update System Core Clock */
;;;616        SystemCoreClockUpdate();
000086  f7fffffe          BL       SystemCoreClockUpdate
00008a  4906              LDR      r1,|L5.164|
00008c  2000              MOVS     r0,#0
00008e  31c0              ADDS     r1,r1,#0xc0
000090  6008              STR      r0,[r1,#0]
;;;617    
;;;618        /* Lock protected registers */
;;;619        SYS_LockReg();
;;;620    }
000092  bd10              POP      {r4,pc}
;;;621    
                          ENDP

                  |L5.148|
                          DCD      0x044aa200
                  |L5.152|
                          DCD      0x57803d10
                  |L5.156|
                          DCD      0x5ec00003
                  |L5.160|
                          DCD      0x5240000c
                  |L5.164|
                          DCD      0x50000040

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1032     */
;;;1033   static __INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1034   {
;;;1035       while(SYS->REGWRPROT != SYS_REGWRPROT_REGPROTDIS_Msk)
;;;1036       {
;;;1037           SYS->REGWRPROT = 0x59;
000002  2159              MOVS     r1,#0x59
;;;1038           SYS->REGWRPROT = 0x16;
000004  2316              MOVS     r3,#0x16
000006  4805              LDR      r0,|L6.28|
;;;1039           SYS->REGWRPROT = 0x88;
000008  2288              MOVS     r2,#0x88
00000a  e002              B        |L6.18|
                  |L6.12|
00000c  6001              STR      r1,[r0,#0]            ;1037
00000e  6003              STR      r3,[r0,#0]            ;1038
000010  6002              STR      r2,[r0,#0]
                  |L6.18|
000012  6804              LDR      r4,[r0,#0]            ;1035
000014  2c01              CMP      r4,#1                 ;1035
000016  d1f9              BNE      |L6.12|
;;;1040       }
;;;1041   }
000018  bd10              POP      {r4,pc}
;;;1042   
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x50000100

                          AREA ||i.SwitchToFunctionPin||, CODE, READONLY, ALIGN=2

                  SwitchToFunctionPin PROC
;;;223    */
;;;224    void SwitchToFunctionPin(unsigned char swap)
000000  2205              MOVS     r2,#5
;;;225    {
000002  b510              PUSH     {r4,lr}
;;;226        if (swap == 0)  // GPIO
;;;227        {
;;;228            PC3 = 1;
;;;229            SYS->GPC_MFP &= ~(SYS_GPC_MFP_PC3_Msk);
000004  0712              LSLS     r2,r2,#28
000006  2308              MOVS     r3,#8
;;;230            SYS->GPC_MFP |= SYS_GPC_MFP_PC3_GPIO;
;;;231            SYS->ALT_MFP &= ~(SYS_ALT_MFP_PC3_Msk);
000008  4910              LDR      r1,|L7.76|
00000a  2800              CMP      r0,#0                 ;226
00000c  d00c              BEQ      |L7.40|
;;;232            SYS->ALT_MFP |= SYS_ALT_MFP_PC3_GPIO;
;;;233            GPIO_SetMode(PC, BIT3, GPIO_PMD_OUTPUT);
;;;234        }
;;;235        else if (swap == 1) // MOSI
00000e  2801              CMP      r0,#1
000010  d109              BNE      |L7.38|
;;;236        {
;;;237            SYS->GPC_MFP &= ~(SYS_GPC_MFP_PC3_Msk);
000012  6b90              LDR      r0,[r2,#0x38]
000014  4398              BICS     r0,r0,r3
000016  6390              STR      r0,[r2,#0x38]
;;;238            SYS->GPC_MFP |= SYS_GPC_MFP_PC3_SPI0_MOSI0;
000018  6b90              LDR      r0,[r2,#0x38]
00001a  4318              ORRS     r0,r0,r3
00001c  6390              STR      r0,[r2,#0x38]
;;;239            SYS->ALT_MFP &= ~(SYS_ALT_MFP_PC3_Msk);
00001e  6908              LDR      r0,[r1,#0x10]
000020  6108              STR      r0,[r1,#0x10]
;;;240            SYS->ALT_MFP |= SYS_ALT_MFP_PC3_SPI0_MOSI0;
000022  6908              LDR      r0,[r1,#0x10]
000024  6108              STR      r0,[r1,#0x10]
                  |L7.38|
;;;241        }
;;;242    
;;;243    }
000026  bd10              POP      {r4,pc}
                  |L7.40|
000028  4c09              LDR      r4,|L7.80|
00002a  2001              MOVS     r0,#1                 ;228
00002c  60e0              STR      r0,[r4,#0xc]          ;228
00002e  6b90              LDR      r0,[r2,#0x38]         ;229
000030  4398              BICS     r0,r0,r3              ;229
000032  6390              STR      r0,[r2,#0x38]         ;229
000034  6b90              LDR      r0,[r2,#0x38]         ;230
000036  6390              STR      r0,[r2,#0x38]         ;230
000038  6908              LDR      r0,[r1,#0x10]         ;231
00003a  6108              STR      r0,[r1,#0x10]         ;231
00003c  6908              LDR      r0,[r1,#0x10]         ;232
00003e  6108              STR      r0,[r1,#0x10]         ;232
000040  2201              MOVS     r2,#1                 ;233
000042  2108              MOVS     r1,#8                 ;233
000044  4803              LDR      r0,|L7.84|
000046  f7fffffe          BL       GPIO_SetMode
00004a  bd10              POP      {r4,pc}
;;;244    
                          ENDP

                  |L7.76|
                          DCD      0x50000040
                  |L7.80|
                          DCD      0x50004280
                  |L7.84|
                          DCD      0x50004080

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;53     
;;;54     void SysTick_Handler(void)
000000  b500              PUSH     {lr}
;;;55     {
;;;56     
;;;57         systick_counter();
000002  f7fffffe          BL       systick_counter
000006  4903              LDR      r1,|L8.20|
000008  6848              LDR      r0,[r1,#4]  ; counter_systick
00000a  1c40              ADDS     r0,r0,#1
;;;58     
;;;59         if (get_systick() >= 0xFFFFFFFF)
00000c  d100              BNE      |L8.16|
00000e  6048              STR      r0,[r1,#4]  ; counter_systick
                  |L8.16|
;;;60         {
;;;61             set_systick(0);      
;;;62         }
;;;63     
;;;64         // if ((get_systick() % 1000) == 0)
;;;65         // {
;;;66            
;;;67         // }
;;;68     
;;;69         #if defined (ENABLE_TICK_EVENT)
;;;70         TickCheckTickEvent();
;;;71         #endif    
;;;72     }
000010  bd00              POP      {pc}
;;;73     
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      ||.data||

                          AREA ||i.SysTick_delay||, CODE, READONLY, ALIGN=2

                  SysTick_delay PROC
;;;73     
;;;74     void SysTick_delay(unsigned int delay)
000000  4903              LDR      r1,|L9.16|
000002  684a              LDR      r2,[r1,#4]  ; counter_systick
                  |L9.4|
000004  684b              LDR      r3,[r1,#4]  ; counter_systick
;;;75     {  
;;;76         
;;;77         unsigned int tickstart = get_systick(); 
;;;78         unsigned int wait = delay; 
;;;79     
;;;80         while((get_systick() - tickstart) < wait) 
000006  1a9b              SUBS     r3,r3,r2
000008  4283              CMP      r3,r0
00000a  d3fb              BCC      |L9.4|
;;;81         { 
;;;82         } 
;;;83     
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      ||.data||

                          AREA ||i.SysTick_enable||, CODE, READONLY, ALIGN=2

                  SysTick_enable PROC
;;;85     
;;;86     void SysTick_enable(unsigned int ticks_per_second)
000000  b510              PUSH     {r4,lr}
000002  4b12              LDR      r3,|L10.76|
;;;87     {
;;;88         set_systick(0);
000004  2200              MOVS     r2,#0
000006  605a              STR      r2,[r3,#4]  ; counter_systick
;;;89         if (SysTick_Config(SystemCoreClock / ticks_per_second))
000008  4601              MOV      r1,r0
00000a  4811              LDR      r0,|L10.80|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  4910              LDR      r1,|L10.84|
000014  4288              CMP      r0,r1
000016  d901              BLS      |L10.28|
000018  2001              MOVS     r0,#1
00001a  e010              B        |L10.62|
                  |L10.28|
00001c  0201              LSLS     r1,r0,#8
00001e  0a09              LSRS     r1,r1,#8
000020  480d              LDR      r0,|L10.88|
000022  1e49              SUBS     r1,r1,#1
000024  6141              STR      r1,[r0,#0x14]
000026  490d              LDR      r1,|L10.92|
000028  2207              MOVS     r2,#7
00002a  69cb              LDR      r3,[r1,#0x1c]
00002c  021b              LSLS     r3,r3,#8
00002e  0a1b              LSRS     r3,r3,#8
000030  0444              LSLS     r4,r0,#17
000032  4323              ORRS     r3,r3,r4
000034  61cb              STR      r3,[r1,#0x1c]
000036  2100              MOVS     r1,#0
000038  6181              STR      r1,[r0,#0x18]
00003a  6102              STR      r2,[r0,#0x10]
00003c  4608              MOV      r0,r1
                  |L10.62|
00003e  2800              CMP      r0,#0
000040  d003              BEQ      |L10.74|
;;;90         {
;;;91             /* Setup SysTick Timer for 1 second interrupts  */
;;;92             printf("Set system tick error!!\n");
000042  a007              ADR      r0,|L10.96|
000044  f7fffffe          BL       __2printf
                  |L10.72|
;;;93             while (1);
000048  e7fe              B        |L10.72|
                  |L10.74|
;;;94         }
;;;95     
;;;96         #if defined (ENABLE_TICK_EVENT)
;;;97         TickInitTickEvent();
;;;98         #endif
;;;99     }
00004a  bd10              POP      {r4,pc}
;;;100    
                          ENDP

                  |L10.76|
                          DCD      ||.data||
                  |L10.80|
                          DCD      SystemCoreClock
                  |L10.84|
                          DCD      0x00ffffff
                  |L10.88|
                          DCD      0xe000e000
                  |L10.92|
                          DCD      0xe000ed04
                  |L10.96|
000060  53657420          DCB      "Set system tick error!!\n",0
000064  73797374
000068  656d2074
00006c  69636b20
000070  6572726f
000074  7221210a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;428    
;;;429    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;430    {
;;;431        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L11.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1508              ASRS     r0,r1,#20
00001c  4904              LDR      r1,|L11.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;432        TIMER_EnableInt(TIMER1);
;;;433        NVIC_EnableIRQ(TMR1_IRQn);	
;;;434        TIMER_Start(TIMER1);
;;;435    }
000028  bd10              POP      {r4,pc}
;;;436    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x40010020
                  |L11.48|
                          DCD      0xe000e100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;403    
;;;404    void TMR1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4811              LDR      r0,|L12.72|
000004  6881              LDR      r1,[r0,#8]
000006  07c9              LSLS     r1,r1,#31
000008  0fc9              LSRS     r1,r1,#31
;;;405    {
00000a  d01c              BEQ      |L12.70|
00000c  2601              MOVS     r6,#1
00000e  6086              STR      r6,[r0,#8]
;;;406    	
;;;407        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;408        {
;;;409            TIMER_ClearIntFlag(TIMER1);
;;;410    		tick_counter();
000010  f7fffffe          BL       tick_counter
000014  4d0d              LDR      r5,|L12.76|
000016  68a8              LDR      r0,[r5,#8]  ; counter_tick
;;;411    
;;;412    		if ((get_tick() % 1000) == 0)
000018  217d              MOVS     r1,#0x7d
00001a  00c9              LSLS     r1,r1,#3
00001c  f7fffffe          BL       __aeabi_uidivmod
;;;413    		{
;;;414                FLAG_PROJ_TIMER_PERIOD_1000MS = 1;//set_flag(flag_timer_period_1000ms ,ENABLE);
000020  462c              MOV      r4,r5
000022  3418              ADDS     r4,r4,#0x18
000024  2900              CMP      r1,#0                 ;412
000026  d102              BNE      |L12.46|
000028  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
00002a  4330              ORRS     r0,r0,r6
00002c  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
                  |L12.46|
00002e  68a8              LDR      r0,[r5,#8]  ; counter_tick
;;;415    		}
;;;416    
;;;417    		if ((get_tick() % 500) == 0)
000030  21ff              MOVS     r1,#0xff
000032  31f5              ADDS     r1,r1,#0xf5
000034  f7fffffe          BL       __aeabi_uidivmod
000038  2900              CMP      r1,#0
00003a  d103              BNE      |L12.68|
;;;418    		{
;;;419                FLAG_PROJ_TIMER_PERIOD_SPECIFIC = 1;
00003c  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
00003e  2102              MOVS     r1,#2
000040  4308              ORRS     r0,r0,r1
000042  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
                  |L12.68|
000044  68a8              LDR      r0,[r5,#8]  ; counter_tick
                  |L12.70|
;;;420    		}
;;;421    
;;;422    		if ((get_tick() % 50) == 0)
;;;423    		{
;;;424    
;;;425    		}	
;;;426        }
;;;427    }
000046  bd70              POP      {r4-r6,pc}
;;;428    
                          ENDP

                  |L12.72|
                          DCD      0x40010020
                  |L12.76|
                          DCD      ||.data||

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;522    
;;;523    void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;524    {
;;;525    
;;;526        if(UART_GET_INT_FLAG(UART0, UART_ISR_RDA_INT_Msk | UART_ISR_TOUT_IF_Msk))     /* UART receive data available flag */
000002  4c06              LDR      r4,|L13.28|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  21ff              MOVS     r1,#0xff
000008  3111              ADDS     r1,r1,#0x11
00000a  4208              TST      r0,r1
00000c  d102              BNE      |L13.20|
;;;527        {
;;;528            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;529            {
;;;530                UARTx_Process();
;;;531            }
;;;532        }
;;;533    
;;;534    }
00000e  bd10              POP      {r4,pc}
                  |L13.16|
000010  f7fffffe          BL       UARTx_Process
                  |L13.20|
000014  69a0              LDR      r0,[r4,#0x18]         ;528
000016  0440              LSLS     r0,r0,#17             ;528
000018  d5fa              BPL      |L13.16|
00001a  bd10              POP      {r4,pc}
;;;535    
                          ENDP

                  |L13.28|
                          DCD      0x40050000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;535    
;;;536    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;537    {
;;;538        SYS_ResetModule(UART0_RST);
000002  4818              LDR      r0,|L14.100|
000004  f7fffffe          BL       SYS_ResetModule
;;;539    
;;;540        /* Configure UART0 and set UART0 baud rate */
;;;541        UART_Open(UART0, 115200);
000008  4c17              LDR      r4,|L14.104|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;542        UART_EnableInt(UART0, UART_IER_RDA_IEN_Msk | UART_IER_TOUT_IEN_Msk);
000014  2111              MOVS     r1,#0x11
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_EnableInt
00001c  2001              MOVS     r0,#1
00001e  4913              LDR      r1,|L14.108|
000020  0300              LSLS     r0,r0,#12
000022  6008              STR      r0,[r1,#0]
;;;543        NVIC_EnableIRQ(UART02_IRQn);
;;;544    	
;;;545    	#if (_debug_log_UART_ == 1)	//debug
;;;546    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000024  f7fffffe          BL       CLK_GetCPUFreq
000028  4601              MOV      r1,r0
00002a  a011              ADR      r0,|L14.112|
00002c  f7fffffe          BL       __2printf
;;;547    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());
000030  f7fffffe          BL       CLK_GetHCLKFreq
000034  4601              MOV      r1,r0
000036  a015              ADR      r0,|L14.140|
000038  f7fffffe          BL       __2printf
;;;548    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00003c  f7fffffe          BL       CLK_GetHXTFreq
000040  4601              MOV      r1,r0
000042  a018              ADR      r0,|L14.164|
000044  f7fffffe          BL       __2printf
;;;549    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000048  f7fffffe          BL       CLK_GetLXTFreq
00004c  4601              MOV      r1,r0
00004e  a01b              ADR      r0,|L14.188|
000050  f7fffffe          BL       __2printf
;;;550    	printf("CLK_GetPCLKFreq : %8d\r\n",CLK_GetPCLKFreq());	
000054  f7fffffe          BL       CLK_GetPCLKFreq
000058  4601              MOV      r1,r0
00005a  a01e              ADR      r0,|L14.212|
00005c  f7fffffe          BL       __2printf
;;;551    	#endif	
;;;552    
;;;553        #if 0
;;;554        printf("FLAG_PROJ_TIMER_PERIOD_1000MS : 0x%2X\r\n",FLAG_PROJ_TIMER_PERIOD_1000MS);
;;;555        printf("FLAG_PROJ_REVERSE1 : 0x%2X\r\n",FLAG_PROJ_REVERSE1);
;;;556        printf("FLAG_PROJ_REVERSE2 : 0x%2X\r\n",FLAG_PROJ_REVERSE2);
;;;557        printf("FLAG_PROJ_REVERSE3 : 0x%2X\r\n",FLAG_PROJ_REVERSE3);
;;;558        printf("FLAG_PROJ_REVERSE4 : 0x%2X\r\n",FLAG_PROJ_REVERSE4);
;;;559        printf("FLAG_PROJ_REVERSE5 : 0x%2X\r\n",FLAG_PROJ_REVERSE5);
;;;560        printf("FLAG_PROJ_REVERSE6 : 0x%2X\r\n",FLAG_PROJ_REVERSE6);
;;;561        printf("FLAG_PROJ_REVERSE7 : 0x%2X\r\n",FLAG_PROJ_REVERSE7);
;;;562        #endif
;;;563    
;;;564    }
000060  bd10              POP      {r4,pc}
;;;565    
                          ENDP

000062  0000              DCW      0x0000
                  |L14.100|
                          DCD      0x04000010
                  |L14.104|
                          DCD      0x40050000
                  |L14.108|
                          DCD      0xe000e100
                  |L14.112|
000070  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000074  4b5f4765
000078  74435055
00007c  46726571
000080  203a2025
000084  38640d0a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L14.140|
00008c  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
000090  47657448
000094  434c4b46
000098  72657120
00009c  3a202538
0000a0  640d0a00
                  |L14.164|
0000a4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a8  47657448
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L14.188|
0000bc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c0  4765744c
0000c4  58544672
0000c8  6571203a
0000cc  20253864
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L14.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLKFreq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b46
0000e0  72657120
0000e4  3a202538
0000e8  640d0a00

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  UARTx_Process PROC
;;;482    
;;;483    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;484    {
;;;485    	uint8_t res = 0;
;;;486    	res = UART_READ(UART0);
000002  4819              LDR      r0,|L15.104|
000004  6800              LDR      r0,[r0,#0]
000006  b2c4              UXTB     r4,r0
;;;487    
;;;488    	if (res > 0x7F)
000008  2c7f              CMP      r4,#0x7f
00000a  d903              BLS      |L15.20|
;;;489    	{
;;;490    		printf("invalid command\r\n");
00000c  a017              ADR      r0,|L15.108|
00000e  f7fffffe          BL       __2printf
                  |L15.18|
;;;491    	}
;;;492    	else
;;;493    	{
;;;494    		printf("press : %c\r\n" , res);
;;;495    		switch(res)
;;;496    		{
;;;497    			case '0':
;;;498                    FLAG_PROJ_SPI_MODE_0 = 1;
;;;499    				break;
;;;500    			case '1':
;;;501                    FLAG_PROJ_SPI_MODE_1 = 1;
;;;502    				break;
;;;503    			case '2':
;;;504                    FLAG_PROJ_SPI_MODE_2 = 1;
;;;505    				break;
;;;506    			case '3':
;;;507                    FLAG_PROJ_SPI_MODE_3 = 1;
;;;508    				break;
;;;509    
;;;510    			case 'X':
;;;511    			case 'x':
;;;512    			case 'Z':
;;;513    			case 'z':
;;;514                    SYS_UnlockReg();
;;;515    				// NVIC_SystemReset();	// Reset I/O and peripherals , only check BS(FMC_ISPCTL[1])
;;;516                    // SYS_ResetCPU();     // Not reset I/O and peripherals
;;;517                    SYS_ResetChip();    // Reset I/O and peripherals ,  BS(FMC_ISPCTL[1]) reload from CONFIG setting (CBS)	
;;;518    				break;
;;;519    		}
;;;520    	}
;;;521    }
000012  bd10              POP      {r4,pc}
                  |L15.20|
000014  4621              MOV      r1,r4                 ;494
000016  a01a              ADR      r0,|L15.128|
000018  f7fffffe          BL       __2printf
00001c  2c58              CMP      r4,#0x58              ;495
00001e  d012              BEQ      |L15.70|
000020  dc0b              BGT      |L15.58|
000022  481b              LDR      r0,|L15.144|
000024  2c30              CMP      r4,#0x30              ;495
000026  d013              BEQ      |L15.80|
000028  2c31              CMP      r4,#0x31              ;495
00002a  d014              BEQ      |L15.86|
00002c  2c32              CMP      r4,#0x32              ;495
00002e  d017              BEQ      |L15.96|
000030  2c33              CMP      r4,#0x33              ;495
000032  d1ee              BNE      |L15.18|
000034  2220              MOVS     r2,#0x20              ;507
000036  6801              LDR      r1,[r0,#0]            ;508  ; flag_PROJ_CTL
000038  e00f              B        |L15.90|
                  |L15.58|
00003a  2c5a              CMP      r4,#0x5a              ;495
00003c  d003              BEQ      |L15.70|
00003e  2c78              CMP      r4,#0x78              ;495
000040  d001              BEQ      |L15.70|
000042  2c7a              CMP      r4,#0x7a              ;495
000044  d1e5              BNE      |L15.18|
                  |L15.70|
000046  f7fffffe          BL       SYS_UnlockReg
00004a  f7fffffe          BL       SYS_ResetChip
00004e  bd10              POP      {r4,pc}
                  |L15.80|
000050  2204              MOVS     r2,#4                 ;498
000052  6801              LDR      r1,[r0,#0]            ;499  ; flag_PROJ_CTL
000054  e001              B        |L15.90|
                  |L15.86|
000056  6801              LDR      r1,[r0,#0]            ;501  ; flag_PROJ_CTL
000058  2208              MOVS     r2,#8                 ;501
                  |L15.90|
00005a  4311              ORRS     r1,r1,r2              ;498
00005c  6001              STR      r1,[r0,#0]            ;498  ; flag_PROJ_CTL
00005e  bd10              POP      {r4,pc}
                  |L15.96|
000060  2210              MOVS     r2,#0x10              ;504
000062  6801              LDR      r1,[r0,#0]            ;505  ; flag_PROJ_CTL
000064  e7f9              B        |L15.90|
;;;522    
                          ENDP

000066  0000              DCW      0x0000
                  |L15.104|
                          DCD      0x40050000
                  |L15.108|
00006c  696e7661          DCB      "invalid command\r\n",0
000070  6c696420
000074  636f6d6d
000078  616e640d
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L15.128|
000080  70726573          DCB      "press : %c\r\n",0
000084  73203a20
000088  25630d0a
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L15.144|
                          DCD      ||.data||+0x18

                          AREA ||i.Write_SPI_Mode_Record||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  Write_SPI_Mode_Record PROC
;;;146    
;;;147    void Write_SPI_Mode_Record(uint32_t mode)
000000  b570              PUSH     {r4-r6,lr}
;;;148    {
;;;149        record_idx = 0x00;
000002  4e1d              LDR      r6,|L16.120|
000004  4605              MOV      r5,r0                 ;148
000006  2000              MOVS     r0,#0
;;;150    	DataFlashRead(record_idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
000008  4632              MOV      r2,r6
00000a  320c              ADDS     r2,r2,#0xc
00000c  2104              MOVS     r1,#4
00000e  6170              STR      r0,[r6,#0x14]  ; record_idx
000010  f7fffffe          BL       DataFlashRead
;;;151        printf("target mode:0x%04X\r\n", mode);
000014  4629              MOV      r1,r5
000016  a019              ADR      r0,|L16.124|
000018  f7fffffe          BL       __2printf
;;;152        
;;;153        if (Storage_Block[0] == mode)
00001c  4634              MOV      r4,r6
00001e  340c              ADDS     r4,r4,#0xc
000020  6822              LDR      r2,[r4,#0]  ; Storage_Block
000022  42aa              CMP      r2,r5
000024  d104              BNE      |L16.48|
;;;154        {
;;;155    
;;;156            printf("%s:Read mode(NO change) 0x%04X\r\n" ,__FUNCTION__ , Storage_Block[0]);
000026  491b              LDR      r1,|L16.148|
000028  a01b              ADR      r0,|L16.152|
00002a  f7fffffe          BL       __2printf
;;;157            return;
;;;158        }
;;;159        else
;;;160        {
;;;161            Storage_Block[0] = mode;
;;;162    		DataFlashWrite(record_idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
;;;163            printf("%s:Write mode 0x%04X\r\n" ,__FUNCTION__ , Storage_Block[0]);
;;;164            
;;;165    	    DataFlashRead(record_idx , BUFFER_PAGE_SIZE , (uint32_t) &Storage_Block[0]);
;;;166            printf("%s:Read mode[0]:0x%04X\r\n",__FUNCTION__ ,Storage_Block[0]);
;;;167        }
;;;168    
;;;169        printf("reboot\r\n");
;;;170        UART_WAIT_TX_EMPTY(UART0);
;;;171        SYS_UnlockReg();
;;;172        SYS_ResetChip();  
;;;173    
;;;174    }
00002e  bd70              POP      {r4-r6,pc}
                  |L16.48|
000030  4a11              LDR      r2,|L16.120|
000032  6025              STR      r5,[r4,#0]            ;162  ; Storage_Block
000034  320c              ADDS     r2,r2,#0xc            ;162
000036  2104              MOVS     r1,#4                 ;162
000038  6970              LDR      r0,[r6,#0x14]         ;162  ; record_idx
00003a  f7fffffe          BL       DataFlashWrite
00003e  4915              LDR      r1,|L16.148|
000040  a01e              ADR      r0,|L16.188|
000042  6822              LDR      r2,[r4,#0]            ;163  ; Storage_Block
000044  f7fffffe          BL       __2printf
000048  4a0b              LDR      r2,|L16.120|
00004a  2104              MOVS     r1,#4                 ;165
00004c  320c              ADDS     r2,r2,#0xc            ;165
00004e  6970              LDR      r0,[r6,#0x14]         ;165  ; record_idx
000050  f7fffffe          BL       DataFlashRead
000054  490f              LDR      r1,|L16.148|
000056  a01f              ADR      r0,|L16.212|
000058  6822              LDR      r2,[r4,#0]            ;166  ; Storage_Block
00005a  f7fffffe          BL       __2printf
00005e  a024              ADR      r0,|L16.240|
000060  f7fffffe          BL       __2printf
000064  4825              LDR      r0,|L16.252|
                  |L16.102|
000066  6981              LDR      r1,[r0,#0x18]         ;170
000068  00c9              LSLS     r1,r1,#3              ;170
00006a  d5fc              BPL      |L16.102|
00006c  f7fffffe          BL       SYS_UnlockReg
000070  f7fffffe          BL       SYS_ResetChip
000074  bd70              POP      {r4-r6,pc}
;;;175    
                          ENDP

000076  0000              DCW      0x0000
                  |L16.120|
                          DCD      ||.data||
                  |L16.124|
00007c  74617267          DCB      "target mode:0x%04X\r\n",0
000080  6574206d
000084  6f64653a
000088  30782530
00008c  34580d0a
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L16.148|
                          DCD      ||.constdata||
                  |L16.152|
000098  25733a52          DCB      "%s:Read mode(NO change) 0x%04X\r\n",0
00009c  65616420
0000a0  6d6f6465
0000a4  284e4f20
0000a8  6368616e
0000ac  67652920
0000b0  30782530
0000b4  34580d0a
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L16.188|
0000bc  25733a57          DCB      "%s:Write mode 0x%04X\r\n",0
0000c0  72697465
0000c4  206d6f64
0000c8  65203078
0000cc  25303458
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L16.212|
0000d4  25733a52          DCB      "%s:Read mode[0]:0x%04X\r\n",0
0000d8  65616420
0000dc  6d6f6465
0000e0  5b305d3a
0000e4  30782530
0000e8  34580d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L16.240|
0000f0  7265626f          DCB      "reboot\r\n",0
0000f4  6f740d0a
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L16.252|
                          DCD      0x40050000

                          AREA ||i.check_reset_source||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  check_reset_source PROC
;;;308    //
;;;309    uint8_t check_reset_source(void)
000000  b510              PUSH     {r4,lr}
;;;310    {
;;;311        uint32_t src = SYS_GetResetSrc();
000002  f7fffffe          BL       SYS_GetResetSrc
000006  4604              MOV      r4,r0
;;;312    
;;;313        SYS->RSTSRC |= 0x0FF;
000008  2005              MOVS     r0,#5
00000a  0700              LSLS     r0,r0,#28
00000c  6841              LDR      r1,[r0,#4]
00000e  22ff              MOVS     r2,#0xff
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;314        printf("Reset Source <0x%08X>\r\n", src);
000014  4621              MOV      r1,r4
000016  a030              ADR      r0,|L17.216|
000018  f7fffffe          BL       __2printf
;;;315    
;;;316        #if 1   //DEBUG , list reset source
;;;317        if (src & BIT0)
00001c  07e0              LSLS     r0,r4,#31
00001e  d002              BEQ      |L17.38|
;;;318        {
;;;319            printf("0)Power-On Reset Flag\r\n");       
000020  a033              ADR      r0,|L17.240|
000022  f7fffffe          BL       __2printf
                  |L17.38|
;;;320        }
;;;321        if (src & BIT1)
000026  07a0              LSLS     r0,r4,#30
000028  d502              BPL      |L17.48|
;;;322        {
;;;323            printf("1)Reset Pin Reset Flag\r\n");       
00002a  a037              ADR      r0,|L17.264|
00002c  f7fffffe          BL       __2printf
                  |L17.48|
;;;324        }
;;;325        if (src & BIT2)
000030  0760              LSLS     r0,r4,#29
000032  d502              BPL      |L17.58|
;;;326        {
;;;327            printf("2)Watchdog Timer Reset Flag\r\n");       
000034  a03b              ADR      r0,|L17.292|
000036  f7fffffe          BL       __2printf
                  |L17.58|
;;;328        }
;;;329        if (src & BIT3)
00003a  0720              LSLS     r0,r4,#28
00003c  d502              BPL      |L17.68|
;;;330        {
;;;331            printf("3)Low Voltage Reset Flag\r\n");       
00003e  a041              ADR      r0,|L17.324|
000040  f7fffffe          BL       __2printf
                  |L17.68|
;;;332        }
;;;333        if (src & BIT4)
000044  06e0              LSLS     r0,r4,#27
000046  d502              BPL      |L17.78|
;;;334        {
;;;335            printf("4)Brown-Out Detector Reset Flag\r\n");       
000048  a045              ADR      r0,|L17.352|
00004a  f7fffffe          BL       __2printf
                  |L17.78|
;;;336        }
;;;337        if (src & BIT5)
00004e  06a0              LSLS     r0,r4,#26
000050  d502              BPL      |L17.88|
;;;338        {
;;;339            printf("5)SYS Reset Flag\r\n");       
000052  a04c              ADR      r0,|L17.388|
000054  f7fffffe          BL       __2printf
                  |L17.88|
;;;340        }
;;;341        if (src & BIT6)
000058  0660              LSLS     r0,r4,#25
00005a  d502              BPL      |L17.98|
;;;342        {
;;;343            printf("6)Reserved.\r\n");       
00005c  a04e              ADR      r0,|L17.408|
00005e  f7fffffe          BL       __2printf
                  |L17.98|
;;;344        }
;;;345        if (src & BIT7)
000062  0620              LSLS     r0,r4,#24
000064  d502              BPL      |L17.108|
;;;346        {
;;;347            printf("7)CPU Reset Flag \r\n");       
000066  a050              ADR      r0,|L17.424|
000068  f7fffffe          BL       __2printf
                  |L17.108|
;;;348        }
;;;349        #endif
;;;350        
;;;351        if (src & SYS_RSTSRC_RSTS_POR_Msk) {
00006c  07e0              LSLS     r0,r4,#31
00006e  d004              BEQ      |L17.122|
;;;352            SYS_ClearResetSrc(SYS_RSTSRC_RSTS_POR_Msk);
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       SYS_ClearResetSrc
;;;353            
;;;354            printf("power on from POR\r\n");
000076  a051              ADR      r0,|L17.444|
;;;355            return FALSE;
000078  e028              B        |L17.204|
                  |L17.122|
;;;356        }    
;;;357        else if (src & SYS_RSTSRC_RSTS_RESET_Msk)
00007a  07a0              LSLS     r0,r4,#30
00007c  d504              BPL      |L17.136|
;;;358        {
;;;359            SYS_ClearResetSrc(SYS_RSTSRC_RSTS_RESET_Msk);
00007e  2002              MOVS     r0,#2
000080  f7fffffe          BL       SYS_ClearResetSrc
;;;360            
;;;361            printf("power on from nRESET pin\r\n");
000084  a052              ADR      r0,|L17.464|
;;;362            return FALSE;
000086  e021              B        |L17.204|
                  |L17.136|
;;;363        } 
;;;364        else if (src & SYS_RSTSRC_RSTS_WDT_Msk)
000088  0760              LSLS     r0,r4,#29
00008a  d504              BPL      |L17.150|
;;;365        {
;;;366            SYS_ClearResetSrc(SYS_RSTSRC_RSTS_WDT_Msk);
00008c  2004              MOVS     r0,#4
00008e  f7fffffe          BL       SYS_ClearResetSrc
;;;367            
;;;368            printf("power on from WDT Reset\r\n");
000092  a056              ADR      r0,|L17.492|
;;;369            return FALSE;
000094  e01a              B        |L17.204|
                  |L17.150|
;;;370        }    
;;;371        else if (src & SYS_RSTSRC_RSTS_LVR_Msk)
000096  0720              LSLS     r0,r4,#28
000098  d504              BPL      |L17.164|
;;;372        {
;;;373            SYS_ClearResetSrc(SYS_RSTSRC_RSTS_LVR_Msk);
00009a  2008              MOVS     r0,#8
00009c  f7fffffe          BL       SYS_ClearResetSrc
;;;374            
;;;375            printf("power on from LVR Reset\r\n");
0000a0  a059              ADR      r0,|L17.520|
;;;376            return FALSE;
0000a2  e013              B        |L17.204|
                  |L17.164|
;;;377        }    
;;;378        else if (src & SYS_RSTSRC_RSTS_BOD_Msk)
0000a4  06e0              LSLS     r0,r4,#27
0000a6  d504              BPL      |L17.178|
;;;379        {
;;;380            SYS_ClearResetSrc(SYS_RSTSRC_RSTS_BOD_Msk);
0000a8  2010              MOVS     r0,#0x10
0000aa  f7fffffe          BL       SYS_ClearResetSrc
;;;381            
;;;382            printf("power on from BOD Reset\r\n");
0000ae  a05d              ADR      r0,|L17.548|
;;;383            return FALSE;
0000b0  e00c              B        |L17.204|
                  |L17.178|
;;;384        }    
;;;385        else if (src & SYS_RSTSRC_RSTS_SYS_Msk)
0000b2  06a0              LSLS     r0,r4,#26
0000b4  d504              BPL      |L17.192|
;;;386        {
;;;387            SYS_ClearResetSrc(SYS_RSTSRC_RSTS_SYS_Msk);
0000b6  2020              MOVS     r0,#0x20
0000b8  f7fffffe          BL       SYS_ClearResetSrc
;;;388            
;;;389            printf("power on from System Reset\r\n");
0000bc  a060              ADR      r0,|L17.576|
;;;390            return FALSE;
0000be  e005              B        |L17.204|
                  |L17.192|
;;;391        } 
;;;392        else if (src & SYS_RSTSRC_RSTS_CPU_Msk)
0000c0  0620              LSLS     r0,r4,#24
0000c2  d507              BPL      |L17.212|
;;;393        {
;;;394            SYS_ClearResetSrc(SYS_RSTSRC_RSTS_CPU_Msk);
0000c4  2080              MOVS     r0,#0x80
0000c6  f7fffffe          BL       SYS_ClearResetSrc
;;;395    
;;;396            printf("power on from CPU reset\r\n");
0000ca  a065              ADR      r0,|L17.608|
                  |L17.204|
;;;397            return FALSE;         
;;;398        } 
;;;399        
;;;400        printf("power on from unhandle reset source\r\n");
0000cc  f7fffffe          BL       __2printf
;;;401        return FALSE;
0000d0  2000              MOVS     r0,#0
;;;402    }
0000d2  bd10              POP      {r4,pc}
                  |L17.212|
0000d4  a069              ADR      r0,|L17.636|
0000d6  e7f9              B        |L17.204|
;;;403    
                          ENDP

                  |L17.216|
0000d8  52657365          DCB      "Reset Source <0x%08X>\r\n",0
0000dc  7420536f
0000e0  75726365
0000e4  203c3078
0000e8  25303858
0000ec  3e0d0a00
                  |L17.240|
0000f0  3029506f          DCB      "0)Power-On Reset Flag\r\n",0
0000f4  7765722d
0000f8  4f6e2052
0000fc  65736574
000100  20466c61
000104  670d0a00
                  |L17.264|
000108  31295265          DCB      "1)Reset Pin Reset Flag\r\n",0
00010c  73657420
000110  50696e20
000114  52657365
000118  7420466c
00011c  61670d0a
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L17.292|
000124  32295761          DCB      "2)Watchdog Timer Reset Flag\r\n",0
000128  74636864
00012c  6f672054
000130  696d6572
000134  20526573
000138  65742046
00013c  6c61670d
000140  0a00    
000142  00                DCB      0
000143  00                DCB      0
                  |L17.324|
000144  33294c6f          DCB      "3)Low Voltage Reset Flag\r\n",0
000148  7720566f
00014c  6c746167
000150  65205265
000154  73657420
000158  466c6167
00015c  0d0a00  
00015f  00                DCB      0
                  |L17.352|
000160  34294272          DCB      "4)Brown-Out Detector Reset Flag\r\n",0
000164  6f776e2d
000168  4f757420
00016c  44657465
000170  63746f72
000174  20526573
000178  65742046
00017c  6c61670d
000180  0a00    
000182  00                DCB      0
000183  00                DCB      0
                  |L17.388|
000184  35295359          DCB      "5)SYS Reset Flag\r\n",0
000188  53205265
00018c  73657420
000190  466c6167
000194  0d0a00  
000197  00                DCB      0
                  |L17.408|
000198  36295265          DCB      "6)Reserved.\r\n",0
00019c  73657276
0001a0  65642e0d
0001a4  0a00    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L17.424|
0001a8  37294350          DCB      "7)CPU Reset Flag \r\n",0
0001ac  55205265
0001b0  73657420
0001b4  466c6167
0001b8  200d0a00
                  |L17.444|
0001bc  706f7765          DCB      "power on from POR\r\n",0
0001c0  72206f6e
0001c4  2066726f
0001c8  6d20504f
0001cc  520d0a00
                  |L17.464|
0001d0  706f7765          DCB      "power on from nRESET pin\r\n",0
0001d4  72206f6e
0001d8  2066726f
0001dc  6d206e52
0001e0  45534554
0001e4  2070696e
0001e8  0d0a00  
0001eb  00                DCB      0
                  |L17.492|
0001ec  706f7765          DCB      "power on from WDT Reset\r\n",0
0001f0  72206f6e
0001f4  2066726f
0001f8  6d205744
0001fc  54205265
000200  7365740d
000204  0a00    
000206  00                DCB      0
000207  00                DCB      0
                  |L17.520|
000208  706f7765          DCB      "power on from LVR Reset\r\n",0
00020c  72206f6e
000210  2066726f
000214  6d204c56
000218  52205265
00021c  7365740d
000220  0a00    
000222  00                DCB      0
000223  00                DCB      0
                  |L17.548|
000224  706f7765          DCB      "power on from BOD Reset\r\n",0
000228  72206f6e
00022c  2066726f
000230  6d20424f
000234  44205265
000238  7365740d
00023c  0a00    
00023e  00                DCB      0
00023f  00                DCB      0
                  |L17.576|
000240  706f7765          DCB      "power on from System Reset\r\n",0
000244  72206f6e
000248  2066726f
00024c  6d205379
000250  7374656d
000254  20526573
000258  65740d0a
00025c  00      
00025d  00                DCB      0
00025e  00                DCB      0
00025f  00                DCB      0
                  |L17.608|
000260  706f7765          DCB      "power on from CPU reset\r\n",0
000264  72206f6e
000268  2066726f
00026c  6d204350
000270  55207265
000274  7365740d
000278  0a00    
00027a  00                DCB      0
00027b  00                DCB      0
                  |L17.636|
00027c  706f7765          DCB      "power on from unhandle reset source\r\n",0
000280  72206f6e
000284  2066726f
000288  6d20756e
00028c  68616e64
000290  6c652072
000294  65736574
000298  20736f75
00029c  7263650d
0002a0  0a00    
0002a2  00                DCB      0
0002a3  00                DCB      0

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;119    
;;;120    void delay_ms(uint16_t ms)
000000  b510              PUSH     {r4,lr}
000002  4b07              LDR      r3,|L18.32|
000004  6899              LDR      r1,[r3,#8]  ; counter_tick
;;;121    {
;;;122    	#if 1
;;;123        uint32_t tickstart = get_tick();
;;;124        uint32_t wait = ms;
;;;125    	uint32_t tmp = 0;
;;;126    	
;;;127        while (1)
;;;128        {
;;;129    		if (get_tick() > tickstart)	// tickstart = 59000 , tick_counter = 60000
;;;130    		{
;;;131    			tmp = get_tick() - tickstart;
;;;132    		}
;;;133    		else // tickstart = 59000 , tick_counter = 2048
;;;134    		{
;;;135    			tmp = 60000 -  tickstart + get_tick();
000006  4a07              LDR      r2,|L18.36|
000008  1a54              SUBS     r4,r2,r1
                  |L18.10|
00000a  689a              LDR      r2,[r3,#8]  ; counter_tick
00000c  428a              CMP      r2,r1                 ;129
00000e  689a              LDR      r2,[r3,#8]            ;129  ; counter_tick
000010  d901              BLS      |L18.22|
000012  1a52              SUBS     r2,r2,r1              ;131
000014  e000              B        |L18.24|
                  |L18.22|
000016  1912              ADDS     r2,r2,r4
                  |L18.24|
;;;136    		}		
;;;137    		
;;;138    		if (tmp > wait)
000018  4282              CMP      r2,r0
00001a  d9f6              BLS      |L18.10|
;;;139    			break;
;;;140        }
;;;141    	
;;;142    	#else
;;;143    	TIMER_Delay(TIMER0, 1000*ms);
;;;144    	#endif
;;;145    }
00001c  bd10              POP      {r4,pc}
;;;146    
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      ||.data||
                  |L18.36|
                          DCD      0x0000ea60

                          AREA ||i.get_systick||, CODE, READONLY, ALIGN=2

                  get_systick PROC
;;;38     
;;;39     unsigned int get_systick(void)
000000  4801              LDR      r0,|L19.8|
;;;40     {
;;;41     	return (counter_systick);
000002  6840              LDR      r0,[r0,#4]  ; counter_systick
;;;42     }
000004  4770              BX       lr
;;;43     
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      ||.data||

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;100    
;;;101    uint32_t get_tick(void)
000000  4801              LDR      r0,|L20.8|
;;;102    {
;;;103    	return (counter_tick);
000002  6880              LDR      r0,[r0,#8]  ; counter_tick
;;;104    }
000004  4770              BX       lr
;;;105    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      ||.data||

                          AREA ||i.loop||, CODE, READONLY, ALIGN=2

                  loop PROC
;;;436    
;;;437    void loop(void)
000000  b510              PUSH     {r4,lr}
000002  481e              LDR      r0,|L21.124|
000004  6840              LDR      r0,[r0,#4]  ; counter_systick
;;;438    {
;;;439    	// static uint32_t LOG1 = 0;
;;;440    	// static uint32_t LOG2 = 0;
;;;441    
;;;442        if ((get_systick() % 1000) == 0)
;;;443        {
;;;444            // printf("%s(systick) : %4d\r\n",__FUNCTION__,LOG2++);    
;;;445        }
;;;446    
;;;447        if (FLAG_PROJ_TIMER_PERIOD_1000MS)//(is_flag_set(flag_timer_period_1000ms))
000006  4c1d              LDR      r4,|L21.124|
000008  3418              ADDS     r4,r4,#0x18
00000a  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
00000c  07c1              LSLS     r1,r0,#31
00000e  d007              BEQ      |L21.32|
;;;448        {
;;;449            FLAG_PROJ_TIMER_PERIOD_1000MS = 0;//set_flag(flag_timer_period_1000ms ,DISABLE);
000010  0840              LSRS     r0,r0,#1
000012  0040              LSLS     r0,r0,#1
;;;450    
;;;451            // printf("%s(timer) : %4d\r\n",__FUNCTION__,LOG1++);
;;;452            PB4 ^= 1;        
000014  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
000016  481a              LDR      r0,|L21.128|
000018  6901              LDR      r1,[r0,#0x10]
00001a  2201              MOVS     r2,#1
00001c  4051              EORS     r1,r1,r2
00001e  6101              STR      r1,[r0,#0x10]
                  |L21.32|
;;;453        }
;;;454    
;;;455        if (FLAG_PROJ_TIMER_PERIOD_SPECIFIC)
000020  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
000022  0781              LSLS     r1,r0,#30
000024  d504              BPL      |L21.48|
;;;456        {
;;;457            FLAG_PROJ_TIMER_PERIOD_SPECIFIC = 0;
000026  2102              MOVS     r1,#2
000028  4388              BICS     r0,r0,r1
;;;458            SPI_Write_Packet();
00002a  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
00002c  f7fffffe          BL       SPI_Write_Packet
                  |L21.48|
;;;459        }
;;;460    
;;;461        if (FLAG_PROJ_SPI_MODE_0)
000030  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
000032  0741              LSLS     r1,r0,#29
000034  d505              BPL      |L21.66|
;;;462        {
;;;463            FLAG_PROJ_SPI_MODE_0 = 0;
000036  2104              MOVS     r1,#4
000038  4388              BICS     r0,r0,r1
;;;464            Write_SPI_Mode_Record(SPI_MODE_0);
00003a  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       Write_SPI_Mode_Record
                  |L21.66|
;;;465        }
;;;466        if (FLAG_PROJ_SPI_MODE_1)
000042  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
000044  0701              LSLS     r1,r0,#28
000046  d505              BPL      |L21.84|
;;;467        {
;;;468            FLAG_PROJ_SPI_MODE_1 = 0;
000048  2108              MOVS     r1,#8
00004a  4388              BICS     r0,r0,r1
;;;469            Write_SPI_Mode_Record(SPI_MODE_1);
00004c  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
00004e  2002              MOVS     r0,#2
000050  f7fffffe          BL       Write_SPI_Mode_Record
                  |L21.84|
;;;470        }
;;;471        if (FLAG_PROJ_SPI_MODE_2)
000054  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
000056  06c1              LSLS     r1,r0,#27
000058  d505              BPL      |L21.102|
;;;472        {
;;;473            FLAG_PROJ_SPI_MODE_2 = 0;
00005a  2110              MOVS     r1,#0x10
00005c  4388              BICS     r0,r0,r1
;;;474            Write_SPI_Mode_Record(SPI_MODE_2);
00005e  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
000060  4808              LDR      r0,|L21.132|
000062  f7fffffe          BL       Write_SPI_Mode_Record
                  |L21.102|
;;;475        }
;;;476        if (FLAG_PROJ_SPI_MODE_3)
000066  6820              LDR      r0,[r4,#0]  ; flag_PROJ_CTL
000068  0681              LSLS     r1,r0,#26
00006a  d506              BPL      |L21.122|
;;;477        {
;;;478            FLAG_PROJ_SPI_MODE_3 = 0;
00006c  2120              MOVS     r1,#0x20
00006e  4388              BICS     r0,r0,r1
;;;479            Write_SPI_Mode_Record(SPI_MODE_3);
000070  6020              STR      r0,[r4,#0]  ; flag_PROJ_CTL
000072  4804              LDR      r0,|L21.132|
000074  1c80              ADDS     r0,r0,#2
000076  f7fffffe          BL       Write_SPI_Mode_Record
                  |L21.122|
;;;480        }
;;;481    }
00007a  bd10              POP      {r4,pc}
;;;482    
                          ENDP

                  |L21.124|
                          DCD      ||.data||
                  |L21.128|
                          DCD      0x50004240
                  |L21.132|
                          DCD      0x00000802

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;621    
;;;622    int main()
000000  f7fffffe          BL       SYS_Init
;;;623    {
;;;624        SYS_Init();
;;;625    
;;;626    	GPIO_Init();
000004  f7fffffe          BL       GPIO_Init
;;;627    	UART0_Init();
000008  f7fffffe          BL       UART0_Init
;;;628    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;629        check_reset_source();
000010  f7fffffe          BL       check_reset_source
;;;630    
;;;631        SysTick_enable(1000);
000014  207d              MOVS     r0,#0x7d
000016  00c0              LSLS     r0,r0,#3
000018  f7fffffe          BL       SysTick_enable
;;;632        #if defined (ENABLE_TICK_EVENT)
;;;633        TickSetTickEvent(1000, TickCallback_processA);  // 1000 ms
;;;634        TickSetTickEvent(5000, TickCallback_processB);  // 5000 ms
;;;635        #endif
;;;636    
;;;637    	DataFlashInit();
00001c  f7fffffe          BL       DataFlashInit
;;;638    
;;;639        Check_SPI_Mode_Record();
000020  f7fffffe          BL       Check_SPI_Mode_Record
;;;640        SPI_Init();
000024  f7fffffe          BL       SPI_Init
                  |L22.40|
;;;641    
;;;642        /* Got no where to go, just loop forever */
;;;643        while(1)
;;;644        {
;;;645            loop();
000028  f7fffffe          BL       loop
00002c  e7fc              B        |L22.40|
;;;646    
;;;647        }
;;;648    }
;;;649    
                          ENDP


                          AREA ||i.set_systick||, CODE, READONLY, ALIGN=2

                  set_systick PROC
;;;43     
;;;44     void set_systick(unsigned int t)
000000  4901              LDR      r1,|L23.8|
;;;45     {
;;;46     	counter_systick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_systick
;;;47     }
000004  4770              BX       lr
;;;48     
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;105    
;;;106    void set_tick(uint32_t t)
000000  4901              LDR      r1,|L24.8|
;;;107    {
;;;108    	counter_tick = t;
000002  6088              STR      r0,[r1,#8]  ; counter_tick
;;;109    }
000004  4770              BX       lr
;;;110    
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      ||.data||

                          AREA ||i.systick_counter||, CODE, READONLY, ALIGN=2

                  systick_counter PROC
;;;48     
;;;49     void systick_counter(void)
000000  4802              LDR      r0,|L25.12|
;;;50     {
;;;51     	counter_systick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_systick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_systick
;;;52     }
000008  4770              BX       lr
;;;53     
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;110    
;;;111    void tick_counter(void)
000000  4805              LDR      r0,|L26.24|
;;;112    {
;;;113    	counter_tick++;
000002  6881              LDR      r1,[r0,#8]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; counter_tick
000008  6881              LDR      r1,[r0,#8]  ; counter_tick
;;;114        if (get_tick() >= 60000)
00000a  4a04              LDR      r2,|L26.28|
00000c  4291              CMP      r1,r2
00000e  d301              BCC      |L26.20|
;;;115        {
;;;116            set_tick(0);
000010  2100              MOVS     r1,#0
000012  6081              STR      r1,[r0,#8]  ; counter_tick
                  |L26.20|
;;;117        }
;;;118    }
000014  4770              BX       lr
;;;119    
                          ENDP

000016  0000              DCW      0x0000
                  |L26.24|
                          DCD      ||.data||
                  |L26.28|
                          DCD      0x0000ea60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  57726974          DCB      0x57,0x72,0x69,0x74
000004  655f5350          DCB      0x65,0x5f,0x53,0x50
000008  495f4d6f          DCB      0x49,0x5f,0x4d,0x6f
00000c  64655f52          DCB      0x64,0x65,0x5f,0x52
000010  65636f72          DCB      0x65,0x63,0x6f,0x72
000014  6400              DCB      0x64,0x00
                  |symbol_number.83|
000016  4368              DCB      0x43,0x68
000018  65636b5f          DCB      0x65,0x63,0x6b,0x5f
00001c  5350495f          DCB      0x53,0x50,0x49,0x5f
000020  4d6f6465          DCB      0x4d,0x6f,0x64,0x65
000024  5f526563          DCB      0x5f,0x52,0x65,0x63
000028  6f726400          DCB      0x6f,0x72,0x64,0x00
                  |symbol_number.84|
00002c  5350495f          DCB      0x53,0x50,0x49,0x5f
000030  496e6974          DCB      0x49,0x6e,0x69,0x74
000034  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ||cnt||
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  counter_systick
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  Storage_Block
                          DCD      0x00000000
                  u32SPIMode
                          DCD      0x00000000
                  record_idx
                          DCD      0x00000000
                  flag_PROJ_CTL
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_6b33c82f____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____REVSH|
#line 132
|__asm___6_main_c_6b33c82f____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
